# Linux驱动开发中IO模型相关API总结

## 一、阻塞与非阻塞IO

### 1.1 等待队列相关API

#### 定义等待队列头
```c
// 静态定义
DECLARE_WAIT_QUEUE_HEAD(name);

// 动态初始化
wait_queue_head_t my_queue;
init_waitqueue_head(&my_queue);
```

#### 等待事件（阻塞）
```c
// 等待条件为真，可被信号中断
wait_event_interruptible(queue, condition);

// 等待条件为真，不可被信号中断
wait_event(queue, condition);

// 等待条件为真或超时，可被信号中断
wait_event_interruptible_timeout(queue, condition, timeout);

// 等待条件为真或超时，不可被信号中断
wait_event_timeout(queue, condition, timeout);
```

**返回值说明：**
- `wait_event_interruptible`: 成功返回0，被信号中断返回-ERESTARTSYS
- `wait_event_interruptible_timeout`: 条件满足返回剩余jiffies，超时返回0，被信号中断返回-ERESTARTSYS

#### 唤醒等待队列
```c
// 唤醒等待队列上的一个进程
wake_up(&queue);

// 唤醒等待队列上可被中断的进程
wake_up_interruptible(&queue);

// 唤醒等待队列上的所有进程
wake_up_all(&queue);
```

### 1.2 file_operations中的阻塞控制

```c
static ssize_t xxx_read(struct file *filp, char __user *buf, 
                        size_t count, loff_t *ppos)
{
    // 检查是否为非阻塞模式
    if (filp->f_flags & O_NONBLOCK) {
        // 非阻塞模式处理
        if (!data_available)
            return -EAGAIN;
    } else {
        // 阻塞模式处理
        wait_event_interruptible(read_queue, data_available);
    }
    
    // 数据读取操作
    return count;
}
```

## 二、poll/select机制

### 2.1 poll函数实现

在驱动中实现poll方法：

```c
#include <linux/poll.h>

static unsigned int xxx_poll(struct file *filp, poll_table *wait)
{
    unsigned int mask = 0;
    struct xxx_dev *dev = filp->private_data;
    
    // 将等待队列添加到poll_table
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    // 检查设备状态，设置返回掩码
    if (dev->data_available)
        mask |= POLLIN | POLLRDNORM;  // 可读
    
    if (dev->space_available)
        mask |= POLLOUT | POLLWRNORM; // 可写
    
    if (dev->error)
        mask |= POLLERR;              // 错误
    
    if (dev->hangup)
        mask |= POLLHUP;              // 挂断
    
    return mask;
}

static struct file_operations xxx_fops = {
    .owner = THIS_MODULE,
    .poll = xxx_poll,
    // ... 其他操作
};
```

### 2.2 poll返回掩码标志

| 标志 | 说明 |
|------|------|
| POLLIN | 有数据可读 |
| POLLRDNORM | 等同于POLLIN |
| POLLRDBAND | 优先级带数据可读 |
| POLLPRI | 高优先级数据可读 |
| POLLOUT | 可以写数据 |
| POLLWRNORM | 等同于POLLOUT |
| POLLWRBAND | 优先级带数据可写 |
| POLLERR | 发生错误 |
| POLLHUP | 挂起 |
| POLLNVAL | 无效的请求 |

### 2.3 应用层使用示例

```c
// 使用poll
#include <poll.h>

struct pollfd fds[1];
fds[0].fd = fd;
fds[0].events = POLLIN;  // 关心可读事件

int ret = poll(fds, 1, 5000);  // 5秒超时
if (ret > 0) {
    if (fds[0].revents & POLLIN) {
        // 数据可读
        read(fd, buf, count);
    }
}

// 使用select
#include <sys/select.h>

fd_set readfds;
struct timeval timeout;

FD_ZERO(&readfds);
FD_SET(fd, &readfds);
timeout.tv_sec = 5;
timeout.tv_usec = 0;

int ret = select(fd + 1, &readfds, NULL, NULL, &timeout);
if (ret > 0 && FD_ISSET(fd, &readfds)) {
    // 数据可读
    read(fd, buf, count);
}
```

## 三、异步通知（信号驱动IO）

### 3.1 fasync相关API

#### 驱动中的实现

```c
#include <linux/fs.h>

struct xxx_dev {
    struct fasync_struct *async_queue;  // 异步通知结构
    // ... 其他成员
};

// fasync方法实现
static int xxx_fasync(int fd, struct file *filp, int mode)
{
    struct xxx_dev *dev = filp->private_data;
    return fasync_helper(fd, filp, mode, &dev->async_queue);
}

// 发送信号通知应用程序
static void xxx_notify(struct xxx_dev *dev)
{
    if (dev->async_queue) {
        kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    }
}

// release方法中清理
static int xxx_release(struct inode *inode, struct file *filp)
{
    struct xxx_dev *dev = filp->private_data;
    
    // 移除异步通知
    xxx_fasync(-1, filp, 0);
    
    return 0;
}

static struct file_operations xxx_fops = {
    .owner = THIS_MODULE,
    .fasync = xxx_fasync,
    .release = xxx_release,
    // ... 其他操作
};
```

### 3.2 fasync_helper函数

```c
int fasync_helper(int fd, struct file *filp, int on, 
                  struct fasync_struct **fapp);
```

**参数说明：**
- `fd`: 文件描述符
- `filp`: 文件指针
- `on`: 1表示添加到异步通知列表，0表示从列表中移除
- `fapp`: 指向fasync_struct指针的指针

**返回值：** 成功返回0，失败返回负错误码

### 3.3 kill_fasync函数

```c
void kill_fasync(struct fasync_struct **fp, int sig, int band);
```

**参数说明：**
- `fp`: 异步通知结构指针
- `sig`: 要发送的信号（通常为SIGIO）
- `band`: 指示可读还是可写（POLL_IN或POLL_OUT）

### 3.4 应用层使用示例

```c
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>

// 信号处理函数
void sigio_handler(int signum)
{
    printf("收到SIGIO信号\n");
    // 读取数据
    char buf[128];
    read(fd, buf, sizeof(buf));
}

int main(void)
{
    int fd, flags;
    
    // 设置信号处理函数
    signal(SIGIO, sigio_handler);
    
    fd = open("/dev/xxx", O_RDWR);
    
    // 设置文件所有者为当前进程
    fcntl(fd, F_SETOWN, getpid());
    
    // 获取文件标志
    flags = fcntl(fd, F_GETFL);
    
    // 启用异步通知
    fcntl(fd, F_SETFL, flags | FASYNC);
    
    // 进程可以做其他事情，有数据时会收到信号
    while (1) {
        sleep(1);
    }
    
    return 0;
}
```

## 四、AIO（异步IO）

### 4.1 AIO相关结构体

```c
struct kiocb {
    struct file *ki_filp;           // 文件指针
    loff_t ki_pos;                  // 文件位置
    void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
    // ... 其他成员
};
```

### 4.2 驱动中的AIO实现

```c
// 异步读
static ssize_t xxx_aio_read(struct kiocb *iocb, const struct iovec *iov,
                            unsigned long nr_segs, loff_t pos)
{
    // 启动异步读操作
    // 完成后调用 aio_complete()
    
    return -EIOCBQUEUED;  // 表示已加入队列
}

// 异步写
static ssize_t xxx_aio_write(struct kiocb *iocb, const struct iovec *iov,
                             unsigned long nr_segs, loff_t pos)
{
    // 启动异步写操作
    
    return -EIOCBQUEUED;
}

// 完成AIO操作
static void xxx_aio_complete(struct work_struct *work)
{
    // 完成实际的IO操作
    
    // 通知完成
    aio_complete(iocb, ret, 0);
}
```

## 五、mmap内存映射

### 5.1 mmap相关API

```c
#include <linux/mm.h>

static int xxx_mmap(struct file *filp, struct vm_area_struct *vma)
{
    unsigned long size = vma->vm_end - vma->vm_start;
    unsigned long pfn;
    
    // 检查映射大小
    if (size > MMAP_SIZE)
        return -EINVAL;
    
    // 方法1：使用remap_pfn_range映射物理内存
    pfn = virt_to_phys(kernel_buf) >> PAGE_SHIFT;
    if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
        return -EAGAIN;
    
    // 方法2：使用io_remap_pfn_range映射IO内存
    // if (io_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot))
    //     return -EAGAIN;
    
    return 0;
}
```

### 5.2 内存映射函数

#### remap_pfn_range
```c
int remap_pfn_range(struct vm_area_struct *vma,
                    unsigned long addr,
                    unsigned long pfn,
                    unsigned long size,
                    pgprot_t prot);
```

**参数说明：**
- `vma`: 虚拟内存区域
- `addr`: 虚拟地址起始位置
- `pfn`: 物理页帧号（物理地址右移PAGE_SHIFT）
- `size`: 映射大小
- `prot`: 页面保护属性

#### io_remap_pfn_range
用于映射IO内存到用户空间，参数同`remap_pfn_range`。

### 5.3 地址转换宏

```c
// 虚拟地址转物理地址
virt_to_phys(vaddr)

// 物理地址转虚拟地址
phys_to_virt(paddr)

// 虚拟地址转页帧号
virt_to_pfn(vaddr)

// 页帧号转虚拟地址
pfn_to_virt(pfn)
```

### 5.4 vm_area_struct重要成员

```c
struct vm_area_struct {
    unsigned long vm_start;     // 起始虚拟地址
    unsigned long vm_end;       // 结束虚拟地址
    unsigned long vm_flags;     // 标志
    pgprot_t vm_page_prot;      // 页面保护属性
    struct file *vm_file;       // 映射的文件
    void *vm_private_data;      // 私有数据
    const struct vm_operations_struct *vm_ops;  // 操作函数集
};
```

### 5.5 vm_flags常用标志

| 标志 | 说明 |
|------|------|
| VM_READ | 可读 |
| VM_WRITE | 可写 |
| VM_EXEC | 可执行 |
| VM_SHARED | 共享映射 |
| VM_IO | IO内存映射 |
| VM_RESERVED | 保留内存 |

### 5.6 应用层使用示例

```c
#include <sys/mman.h>
#include <fcntl.h>

int fd = open("/dev/xxx", O_RDWR);

// 映射设备内存到用户空间
void *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, 
                  MAP_SHARED, fd, 0);

if (addr == MAP_FAILED) {
    perror("mmap failed");
    return -1;
}

// 直接访问映射的内存
*(int *)addr = 0x12345678;

// 解除映射
munmap(addr, size);
close(fd);
```

## 六、DMA操作相关API

### 6.1 DMA内存分配

```c
#include <linux/dma-mapping.h>

// 分配一致性DMA内存
void *dma_alloc_coherent(struct device *dev, size_t size,
                         dma_addr_t *dma_handle, gfp_t flag);

// 释放一致性DMA内存
void dma_free_coherent(struct device *dev, size_t size,
                       void *cpu_addr, dma_addr_t dma_handle);
```

### 6.2 DMA映射

```c
// 单一缓冲区映射
dma_addr_t dma_map_single(struct device *dev, void *ptr,
                          size_t size, enum dma_data_direction dir);

// 解除单一缓冲区映射
void dma_unmap_single(struct device *dev, dma_addr_t addr,
                      size_t size, enum dma_data_direction dir);

// 页面映射
dma_addr_t dma_map_page(struct device *dev, struct page *page,
                        unsigned long offset, size_t size,
                        enum dma_data_direction dir);

// 解除页面映射
void dma_unmap_page(struct device *dev, dma_addr_t addr,
                    size_t size, enum dma_data_direction dir);
```

### 6.3 DMA方向标志

```c
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,  // 双向
    DMA_TO_DEVICE = 1,      // 到设备
    DMA_FROM_DEVICE = 2,    // 从设备
    DMA_NONE = 3,           // 无DMA
};
```

## 七、完整示例

### 7.1 支持多种IO模型的字符设备

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/poll.h>
#include <linux/sched.h>
#include <linux/wait.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "myio"
#define BUFFER_SIZE 1024

struct myio_dev {
    struct cdev cdev;
    char buffer[BUFFER_SIZE];
    int data_len;
    int write_pos;
    int read_pos;
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;
    struct fasync_struct *async_queue;
    struct mutex mutex;
};

static struct myio_dev *myio_device;
static dev_t dev_number;

static ssize_t myio_read(struct file *filp, char __user *buf,
                         size_t count, loff_t *ppos)
{
    struct myio_dev *dev = filp->private_data;
    int ret;
    
    mutex_lock(&dev->mutex);
    
    // 阻塞等待数据
    while (dev->data_len == 0) {
        mutex_unlock(&dev->mutex);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
            
        if (wait_event_interruptible(dev->read_queue, dev->data_len > 0))
            return -ERESTARTSYS;
            
        mutex_lock(&dev->mutex);
    }
    
    // 读取数据
    if (count > dev->data_len)
        count = dev->data_len;
        
    if (copy_to_user(buf, dev->buffer + dev->read_pos, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    dev->read_pos += count;
    dev->data_len -= count;
    
    // 唤醒写等待队列
    wake_up_interruptible(&dev->write_queue);
    
    ret = count;
    
out:
    mutex_unlock(&dev->mutex);
    return ret;
}

static ssize_t myio_write(struct file *filp, const char __user *buf,
                          size_t count, loff_t *ppos)
{
    struct myio_dev *dev = filp->private_data;
    int ret;
    
    mutex_lock(&dev->mutex);
    
    // 阻塞等待空间
    while (dev->data_len >= BUFFER_SIZE) {
        mutex_unlock(&dev->mutex);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
            
        if (wait_event_interruptible(dev->write_queue, 
                                     dev->data_len < BUFFER_SIZE))
            return -ERESTARTSYS;
            
        mutex_lock(&dev->mutex);
    }
    
    // 写入数据
    if (count > BUFFER_SIZE - dev->data_len)
        count = BUFFER_SIZE - dev->data_len;
        
    if (copy_from_user(dev->buffer + dev->write_pos, buf, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    dev->write_pos += count;
    dev->data_len += count;
    
    // 唤醒读等待队列
    wake_up_interruptible(&dev->read_queue);
    
    // 发送异步通知
    if (dev->async_queue)
        kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    
    ret = count;
    
out:
    mutex_unlock(&dev->mutex);
    return ret;
}

static unsigned int myio_poll(struct file *filp, poll_table *wait)
{
    struct myio_dev *dev = filp->private_data;
    unsigned int mask = 0;
    
    mutex_lock(&dev->mutex);
    
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    if (dev->data_len > 0)
        mask |= POLLIN | POLLRDNORM;
        
    if (dev->data_len < BUFFER_SIZE)
        mask |= POLLOUT | POLLWRNORM;
    
    mutex_unlock(&dev->mutex);
    
    return mask;
}

static int myio_fasync(int fd, struct file *filp, int mode)
{
    struct myio_dev *dev = filp->private_data;
    return fasync_helper(fd, filp, mode, &dev->async_queue);
}

static int myio_open(struct inode *inode, struct file *filp)
{
    struct myio_dev *dev = container_of(inode->i_cdev, 
                                        struct myio_dev, cdev);
    filp->private_data = dev;
    return 0;
}

static int myio_release(struct inode *inode, struct file *filp)
{
    myio_fasync(-1, filp, 0);
    return 0;
}

static struct file_operations myio_fops = {
    .owner = THIS_MODULE,
    .open = myio_open,
    .release = myio_release,
    .read = myio_read,
    .write = myio_write,
    .poll = myio_poll,
    .fasync = myio_fasync,
};

static int __init myio_init(void)
{
    int ret;
    
    // 分配设备号
    ret = alloc_chrdev_region(&dev_number, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;
    
    // 分配设备结构
    myio_device = kzalloc(sizeof(struct myio_dev), GFP_KERNEL);
    if (!myio_device) {
        unregister_chrdev_region(dev_number, 1);
        return -ENOMEM;
    }
    
    // 初始化
    init_waitqueue_head(&myio_device->read_queue);
    init_waitqueue_head(&myio_device->write_queue);
    mutex_init(&myio_device->mutex);
    
    // 注册字符设备
    cdev_init(&myio_device->cdev, &myio_fops);
    ret = cdev_add(&myio_device->cdev, dev_number, 1);
    if (ret) {
        kfree(myio_device);
        unregister_chrdev_region(dev_number, 1);
        return ret;
    }
    
    printk(KERN_INFO "myio: 设备已注册\n");
    return 0;
}

static void __exit myio_exit(void)
{
    cdev_del(&myio_device->cdev);
    kfree(myio_device);
    unregister_chrdev_region(dev_number, 1);
    printk(KERN_INFO "myio: 设备已注销\n");
}

module_init(myio_init);
module_exit(myio_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("IO模型示例驱动");
```

## 八、IO模型对比总结

| IO模型 | 优点 | 缺点 | 适用场景 |
|--------|------|------|----------|
| 阻塞IO | 实现简单，CPU占用低 | 等待时进程阻塞 | 单任务应用 |
| 非阻塞IO | 进程不阻塞，可轮询 | 需要不断轮询，CPU占用高 | 需要同时处理多个任务 |
| IO多路复用(poll/select) | 可同时监控多个文件描述符 | 需要内核支持 | 服务器程序 |
| 信号驱动IO | 异步通知，无需轮询 | 信号处理复杂 | 事件驱动程序 |
| 异步IO(AIO) | 真正异步，性能最好 | 实现复杂 | 高性能IO密集型应用 |
| 内存映射(mmap) | 零拷贝，性能最优 | 只适合可随机访问的设备 | 大数据量传输 |
