# Linux字符设备驱动开发总结

## 第一章 字符设备驱动开发步骤

### 1.1 模块初始化阶段

#### 步骤1：分配设备号（申请洗衣机售卖许可）
- 动态分配（推荐）或静态注册设备号
- 设备号由主设备号和次设备号组成

#### 步骤2：初始化字符设备结构体（洗衣机制造）
- 使用 `cdev_init()` 初始化 cdev 结构
- 绑定 file_operations 操作函数集

#### 步骤3：注册字符设备（把洗衣机放到超市仓库）
- 使用 `cdev_add()` 将字符设备添加到系统
- 此时设备已注册但用户空间还无法访问

#### 步骤4：创建设备类（超市中划出一个家电区）
- 使用 `class_create()` 创建设备类
- 设备类用于自动创建设备节点

#### 步骤5：创建设备节点（把洗衣机从仓库放到家电区开始售卖）
- 使用 `device_create()` 在 /dev 目录下创建设备文件
- 用户空间通过该节点访问驱动

### 1.2 实现文件操作函数

需要实现的主要函数：
- **open**：设备打开时调用，初始化设备
- **release**：设备关闭时调用，释放资源
- **read**：从设备读取数据
- **write**：向设备写入数据
- **unlocked_ioctl**：设备控制命令
- **llseek**：文件定位操作（可选）
- **poll**：轮询操作（可选）

### 1.3 模块卸载阶段

按照初始化的逆序清理资源：

#### 步骤1：删除设备节点
- 使用 `device_destroy()` 删除设备文件

#### 步骤2：销毁设备类
- 使用 `class_destroy()` 销毁设备类

#### 步骤3：注销字符设备
- 使用 `cdev_del()` 从系统中移除字符设备

#### 步骤4：释放设备号
- 使用 `unregister_chrdev_region()` 释放设备号

### 1.4 开发流程图

```
[模块加载]
    ↓
[分配设备号] → alloc_chrdev_region()
    ↓
[初始化cdev] → cdev_init()
    ↓
[注册字符设备] → cdev_add()
    ↓
[创建设备类] → class_create()
    ↓
[创建设备节点] → device_create()
    ↓
[驱动运行中]
    ↓
[删除设备节点] → device_destroy()
    ↓
[销毁设备类] → class_destroy()
    ↓
[注销字符设备] → cdev_del()
    ↓
[释放设备号] → unregister_chrdev_region()
    ↓
[模块卸载]
```

---

## 第二章 常用函数详解

### 2.1 设备号管理函数

#### alloc_chrdev_region() - 动态分配设备号
```c
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
```
- **功能**：动态分配主设备号和一段连续的次设备号
- **参数**：
  - `dev`：输出参数，保存分配的设备号
  - `baseminor`：起始次设备号，通常为0
  - `count`：连续次设备号的数量
  - `name`：设备名称，显示在 /proc/devices 中
- **返回值**：成功返回0，失败返回负数错误码

#### register_chrdev_region() - 静态注册设备号
```c
int register_chrdev_region(dev_t from, unsigned count, const char *name);
```
- **功能**：注册指定的设备号（需提前知道可用的主设备号）
- **参数**：
  - `from`：要注册的起始设备号
  - `count`：设备号数量
  - `name`：设备名称
- **返回值**：成功返回0，失败返回负数错误码

#### unregister_chrdev_region() - 释放设备号
```c
void unregister_chrdev_region(dev_t from, unsigned count);
```
- **功能**：释放已注册的设备号范围
- **参数**：
  - `from`：起始设备号
  - `count`：释放的设备号数量

#### MAJOR() - 获取主设备号
```c
unsigned int MAJOR(dev_t dev);
```
- **功能**：从设备号中提取主设备号

#### MINOR() - 获取次设备号
```c
unsigned int MINOR(dev_t dev);
```
- **功能**：从设备号中提取次设备号

#### MKDEV() - 生成设备号
```c
dev_t MKDEV(unsigned int major, unsigned int minor);
```
- **功能**：将主设备号和次设备号组合成完整的设备号

### 2.2 字符设备注册函数

#### cdev_init() - 初始化字符设备结构体
```c
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
```
- **功能**：初始化 cdev 结构体并绑定文件操作函数集
- **参数**：
  - `cdev`：要初始化的 cdev 结构体指针
  - `fops`：文件操作函数集指针

#### cdev_add() - 注册字符设备到内核
```c
int cdev_add(struct cdev *p, dev_t dev, unsigned count);
```
- **功能**：将字符设备添加到系统，使其生效
- **参数**：
  - `p`：cdev 结构体指针
  - `dev`：设备号
  - `count`：设备数量
- **返回值**：成功返回0，失败返回负数错误码

#### cdev_del() - 从内核注销字符设备
```c
void cdev_del(struct cdev *p);
```
- **功能**：从系统中移除字符设备
- **参数**：
  - `p`：要删除的 cdev 结构体指针

### 2.3 设备类和设备节点函数

#### class_create() - 创建设备类
```c
struct class *class_create(struct module *owner, const char *name);
```
- **功能**：创建设备类，用于自动创建设备文件
- **参数**：
  - `owner`：模块所有者，通常为 THIS_MODULE
  - `name`：类名称
- **返回值**：成功返回 class 指针，失败返回 ERR_PTR

#### class_destroy() - 销毁设备类
```c
void class_destroy(struct class *cls);
```
- **功能**：销毁已创建的设备类
- **参数**：
  - `cls`：要销毁的设备类指针

#### device_create() - 创建设备节点
```c
struct device *device_create(struct class *class, struct device *parent,
                            dev_t devt, void *drvdata, const char *fmt, ...);
```
- **功能**：在 /dev 目录下自动创建设备文件
- **参数**：
  - `class`：设备所属的类
  - `parent`：父设备，通常为 NULL
  - `devt`：设备号
  - `drvdata`：私有数据指针
  - `fmt`：设备名称格式化字符串
- **返回值**：成功返回 device 指针，失败返回 ERR_PTR

#### device_destroy() - 销毁设备节点
```c
void device_destroy(struct class *class, dev_t devt);
```
- **功能**：删除设备文件
- **参数**：
  - `class`：设备所属的类
  - `devt`：设备号

### 2.4 用户空间数据传输函数

#### copy_to_user() - 内核空间数据拷贝到用户空间
```c
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
```
- **功能**：安全地将数据从内核空间复制到用户空间
- **参数**：
  - `to`：用户空间目标地址
  - `from`：内核空间源地址
  - `n`：要复制的字节数
- **返回值**：未能复制的字节数，成功返回0

#### copy_from_user() - 用户空间数据拷贝到内核空间
```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);
```
- **功能**：安全地将数据从用户空间复制到内核空间
- **参数**：
  - `to`：内核空间目标地址
  - `from`：用户空间源地址
  - `n`：要复制的字节数
- **返回值**：未能复制的字节数，成功返回0

#### put_user() - 发送简单变量到用户空间
```c
int put_user(x, ptr);
```
- **功能**：将简单类型变量（1、2、4、8字节）发送到用户空间
- **参数**：
  - `x`：要发送的值
  - `ptr`：用户空间指针
- **返回值**：成功返回0，失败返回 -EFAULT

#### get_user() - 从用户空间获取简单变量
```c
int get_user(x, ptr);
```
- **功能**：从用户空间获取简单类型变量
- **参数**：
  - `x`：用于存储获取值的变量
  - `ptr`：用户空间指针
- **返回值**：成功返回0，失败返回 -EFAULT

### 2.5 内存分配函数

#### kmalloc() - 分配内核内存
```c
void *kmalloc(size_t size, gfp_t flags);
```
- **功能**：在内核空间分配内存
- **参数**：
  - `size`：要分配的字节数
  - `flags`：分配标志
    - `GFP_KERNEL`：常规分配，可能睡眠
    - `GFP_ATOMIC`：原子分配，不会睡眠（用于中断上下文）
- **返回值**：成功返回内存指针，失败返回 NULL

#### kfree() - 释放内核内存
```c
void kfree(const void *ptr);
```
- **功能**：释放 kmalloc 分配的内存
- **参数**：
  - `ptr`：要释放的内存指针

#### kzalloc() - 分配并清零内核内存
```c
void *kzalloc(size_t size, gfp_t flags);
```
- **功能**：分配内存并将其初始化为0
- **参数**：与 kmalloc 相同
- **返回值**：成功返回内存指针，失败返回 NULL

### 2.6 同步与互斥函数

#### mutex_init() - 初始化互斥锁
```c
void mutex_init(struct mutex *lock);
```
- **功能**：初始化互斥量

#### mutex_lock() - 获取互斥锁
```c
void mutex_lock(struct mutex *lock);
```
- **功能**：获取互斥锁，如果锁已被占用则睡眠等待

#### mutex_unlock() - 释放互斥锁
```c
void mutex_unlock(struct mutex *lock);
```
- **功能**：释放互斥锁

#### spin_lock_init() - 初始化自旋锁
```c
void spin_lock_init(spinlock_t *lock);
```
- **功能**：初始化自旋锁

#### spin_lock() / spin_unlock() - 自旋锁操作
```c
void spin_lock(spinlock_t *lock);
void spin_unlock(spinlock_t *lock);
```
- **功能**：获取/释放自旋锁（用于短时间临界区，不会睡眠）

### 2.7 其他常用函数

#### container_of() - 通过成员指针获取结构体指针
```c
container_of(ptr, type, member);
```
- **功能**：通过结构体成员指针获取结构体起始地址
- **参数**：
  - `ptr`：指向成员的指针
  - `type`：结构体类型
  - `member`：成员名称

#### printk() - 内核日志打印
```c
printk(KERN_LEVEL "format", ...);
```
- **功能**：向内核日志缓冲区输出信息
- **日志级别**：
  - `KERN_EMERG`：紧急情况
  - `KERN_ALERT`：必须立即采取行动
  - `KERN_CRIT`：严重错误
  - `KERN_ERR`：错误
  - `KERN_WARNING`：警告
  - `KERN_NOTICE`：注意
  - `KERN_INFO`：信息
  - `KERN_DEBUG`：调试信息

#### ioremap() - 映射物理地址到虚拟地址
```c
void __iomem *ioremap(phys_addr_t offset, size_t size);
```
- **功能**：将物理地址映射到内核虚拟地址空间
- **参数**：
  - `offset`：物理地址
  - `size`：映射大小
- **返回值**：虚拟地址指针

#### iounmap() - 取消地址映射
```c
void iounmap(void __iomem *addr);
```
- **功能**：释放 ioremap 创建的映射
- **参数**：
  - `addr`：要取消映射的虚拟地址

---

## 第三章 完整示例代码

### 3.1 字符设备驱动源码（mychardev.c）

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>

#define DEVICE_NAME "mychardev"
#define DEVICE_COUNT 1
#define BUFFER_SIZE 1024

/* 设备结构体 */
struct mychar_device {
    struct cdev cdev;               // 字符设备结构
    dev_t devno;                    // 设备号
    struct class *class;            // 设备类
    struct device *device;          // 设备
    char *buffer;                   // 数据缓冲区
    size_t buffer_size;             // 缓冲区大小
    struct mutex mutex;             // 互斥锁
};

static struct mychar_device *mydev;

/* open 函数 */
static int mychar_open(struct inode *inode, struct file *filp)
{
    struct mychar_device *dev;
    
    /* 通过 inode 获取设备结构体 */
    dev = container_of(inode->i_cdev, struct mychar_device, cdev);
    filp->private_data = dev;
    
    printk(KERN_INFO "mychardev: Device opened\n");
    return 0;
}

/* release 函数 */
static int mychar_release(struct inode *inode, struct file *filp)
{
    printk(KERN_INFO "mychardev: Device closed\n");
    return 0;
}

/* read 函数 */
static ssize_t mychar_read(struct file *filp, char __user *buf, 
                          size_t count, loff_t *f_pos)
{
    struct mychar_device *dev = filp->private_data;
    size_t bytes_to_read;
    int ret;
    
    /* 加锁保护 */
    if (mutex_lock_interruptible(&dev->mutex))
        return -ERESTARTSYS;
    
    /* 检查读取位置 */
    if (*f_pos >= dev->buffer_size) {
        mutex_unlock(&dev->mutex);
        return 0;  // EOF
    }
    
    /* 计算实际读取字节数 */
    bytes_to_read = min(count, dev->buffer_size - (size_t)*f_pos);
    
    /* 拷贝数据到用户空间 */
    ret = copy_to_user(buf, dev->buffer + *f_pos, bytes_to_read);
    if (ret) {
        mutex_unlock(&dev->mutex);
        return -EFAULT;
    }
    
    *f_pos += bytes_to_read;
    mutex_unlock(&dev->mutex);
    
    printk(KERN_INFO "mychardev: Read %zu bytes\n", bytes_to_read);
    return bytes_to_read;
}

/* write 函数 */
static ssize_t mychar_write(struct file *filp, const char __user *buf,
                           size_t count, loff_t *f_pos)
{
    struct mychar_device *dev = filp->private_data;
    size_t bytes_to_write;
    int ret;
    
    /* 加锁保护 */
    if (mutex_lock_interruptible(&dev->mutex))
        return -ERESTARTSYS;
    
    /* 检查写入位置 */
    if (*f_pos >= BUFFER_SIZE) {
        mutex_unlock(&dev->mutex);
        return -ENOSPC;  // 没有空间
    }
    
    /* 计算实际写入字节数 */
    bytes_to_write = min(count, (size_t)(BUFFER_SIZE - *f_pos));
    
    /* 从用户空间拷贝数据 */
    ret = copy_from_user(dev->buffer + *f_pos, buf, bytes_to_write);
    if (ret) {
        mutex_unlock(&dev->mutex);
        return -EFAULT;
    }
    
    *f_pos += bytes_to_write;
    if (*f_pos > dev->buffer_size)
        dev->buffer_size = *f_pos;
    
    mutex_unlock(&dev->mutex);
    
    printk(KERN_INFO "mychardev: Written %zu bytes\n", bytes_to_write);
    return bytes_to_write;
}

/* llseek 函数 */
static loff_t mychar_llseek(struct file *filp, loff_t offset, int whence)
{
    struct mychar_device *dev = filp->private_data;
    loff_t new_pos;
    
    switch (whence) {
    case SEEK_SET:
        new_pos = offset;
        break;
    case SEEK_CUR:
        new_pos = filp->f_pos + offset;
        break;
    case SEEK_END:
        new_pos = dev->buffer_size + offset;
        break;
    default:
        return -EINVAL;
    }
    
    if (new_pos < 0 || new_pos > BUFFER_SIZE)
        return -EINVAL;
    
    filp->f_pos = new_pos;
    return new_pos;
}

/* 文件操作结构体 */
static struct file_operations mychar_fops = {
    .owner = THIS_MODULE,
    .open = mychar_open,
    .release = mychar_release,
    .read = mychar_read,
    .write = mychar_write,
    .llseek = mychar_llseek,
};

/* 模块初始化函数 */
static int __init mychar_init(void)
{
    int ret;
    
    printk(KERN_INFO "mychardev: Initializing module\n");
    
    /* 分配设备结构体 */
    mydev = kzalloc(sizeof(struct mychar_device), GFP_KERNEL);
    if (!mydev) {
        printk(KERN_ERR "mychardev: Failed to allocate memory\n");
        return -ENOMEM;
    }
    
    /* 分配数据缓冲区 */
    mydev->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
    if (!mydev->buffer) {
        printk(KERN_ERR "mychardev: Failed to allocate buffer\n");
        kfree(mydev);
        return -ENOMEM;
    }
    mydev->buffer_size = 0;
    
    /* 初始化互斥锁 */
    mutex_init(&mydev->mutex);
    
    /* 1. 动态分配设备号 */
    ret = alloc_chrdev_region(&mydev->devno, 0, DEVICE_COUNT, DEVICE_NAME);
    if (ret < 0) {
        printk(KERN_ERR "mychardev: Failed to allocate device number\n");
        kfree(mydev->buffer);
        kfree(mydev);
        return ret;
    }
    printk(KERN_INFO "mychardev: Device number: Major=%d, Minor=%d\n",
           MAJOR(mydev->devno), MINOR(mydev->devno));
    
    /* 2. 初始化并添加字符设备 */
    cdev_init(&mydev->cdev, &mychar_fops);
    mydev->cdev.owner = THIS_MODULE;
    ret = cdev_add(&mydev->cdev, mydev->devno, DEVICE_COUNT);
    if (ret < 0) {
        printk(KERN_ERR "mychardev: Failed to add cdev\n");
        unregister_chrdev_region(mydev->devno, DEVICE_COUNT);
        kfree(mydev->buffer);
        kfree(mydev);
        return ret;
    }
    
    /* 3. 创建设备类 */
    mydev->class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(mydev->class)) {
        printk(KERN_ERR "mychardev: Failed to create class\n");
        ret = PTR_ERR(mydev->class);
        cdev_del(&mydev->cdev);
        unregister_chrdev_region(mydev->devno, DEVICE_COUNT);
        kfree(mydev->buffer);
        kfree(mydev);
        return ret;
    }
    
    /* 4. 创建设备节点 */
    mydev->device = device_create(mydev->class, NULL, mydev->devno, 
                                  NULL, DEVICE_NAME);
    if (IS_ERR(mydev->device)) {
        printk(KERN_ERR "mychardev: Failed to create device\n");
        ret = PTR_ERR(mydev->device);
        class_destroy(mydev->class);
        cdev_del(&mydev->cdev);
        unregister_chrdev_region(mydev->devno, DEVICE_COUNT);
        kfree(mydev->buffer);
        kfree(mydev);
        return ret;
    }
    
    printk(KERN_INFO "mychardev: Device created successfully at /dev/%s\n", 
           DEVICE_NAME);
    return 0;
}

/* 模块退出函数 */
static void __exit mychar_exit(void)
{
    printk(KERN_INFO "mychardev: Exiting module\n");
    
    /* 按照初始化的逆序清理 */
    device_destroy(mydev->class, mydev->devno);
    class_destroy(mydev->class);
    cdev_del(&mydev->cdev);
    unregister_chrdev_region(mydev->devno, DEVICE_COUNT);
    kfree(mydev->buffer);
    kfree(mydev);
    
    printk(KERN_INFO "mychardev: Module exited\n");
}

module_init(mychar_init);
module_exit(mychar_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple character device driver example");
MODULE_VERSION("1.0");
```

### 3.2 Makefile

```makefile
# 模块名称
obj-m := mychardev.o

# 内核源码路径
KDIR := /lib/modules/$(shell uname -r)/build

# 当前目录
PWD := $(shell pwd)

# 编译目标
all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

# 清理目标
clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

# 安装模块
install:
	$(MAKE) -C $(KDIR) M=$(PWD) modules_install
	depmod -a

# 帮助信息
help:
	@echo "make          - 编译内核模块"
	@echo "make clean    - 清理编译文件"
	@echo "make install  - 安装模块到系统"
```

### 3.3 测试程序（test.c）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#define DEVICE_PATH "/dev/mychardev"
#define BUFFER_SIZE 1024

int main(int argc, char *argv[])
{
    int fd;
    char write_buf[BUFFER_SIZE];
    char read_buf[BUFFER_SIZE];
    ssize_t ret;
    
    printf("=== Character Device Test Program ===\n\n");
    
    /* 打开设备 */
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device");
        return EXIT_FAILURE;
    }
    printf("Device opened successfully\n");
    
    /* 写入数据 */
    snprintf(write_buf, BUFFER_SIZE, "Hello from user space! PID=%d\n", getpid());
    ret = write(fd, write_buf, strlen(write_buf));
    if (ret < 0) {
        perror("Failed to write to device");
        close(fd);
        return EXIT_FAILURE;
    }
    printf("Written %zd bytes: %s", ret, write_buf);
    
    /* 重定位到文件开头 */
    lseek(fd, 0, SEEK_SET);
    
    /* 读取数据 */
    memset(read_buf, 0, BUFFER_SIZE);
    ret = read(fd, read_buf, BUFFER_SIZE);
    if (ret < 0) {
        perror("Failed to read from device");
        close(fd);
        return EXIT_FAILURE;
    }
    printf("Read %zd bytes: %s", ret, read_buf);
    
    /* 验证数据 */
    if (strcmp(write_buf, read_buf) == 0) {
        printf("\n✓ Data verification passed!\n");
    } else {
        printf("\n✗ Data verification failed!\n");
    }
    
    /* 关闭设备 */
    close(fd);
    printf("\nDevice closed\n");
    
    return EXIT_SUCCESS;
}
```

### 3.4 编译和测试脚本（test.sh）

```bash
#!/bin/bash

echo "=== Linux Character Device Driver Test ==="
echo ""

# 编译驱动模块
echo "[1] Compiling kernel module..."
make clean
make
if [ $? -ne 0 ]; then
    echo "Error: Failed to compile module"
    exit 1
fi
echo "✓ Module compiled successfully"
echo ""

# 加载模块
echo "[2] Loading kernel module..."
sudo insmod mychardev.ko
if [ $? -ne 0 ]; then
    echo "Error: Failed to load module"
    exit 1
fi
echo "✓ Module loaded successfully"
echo ""

# 检查设备文件
echo "[3] Checking device file..."
if [ -e /dev/mychardev ]; then
    ls -l /dev/mychardev
    echo "✓ Device file created"
else
    echo "Error: Device file not found"
    sudo rmmod mychardev
    exit 1
fi
echo ""

# 编译测试程序
echo "[4] Compiling test program..."
gcc -o test test.c
if [ $? -ne 0 ]; then
    echo "Error: Failed to compile test program"
    sudo rmmod mychardev
    exit 1
fi
echo "✓ Test program compiled"
echo ""

# 运行测试
echo "[5] Running test program..."
sudo ./test
echo ""

# 查看内核日志
echo "[6] Kernel messages:"
dmesg | tail -20 | grep mychardev
echo ""

# 清理
echo "[7] Cleanup..."
read -p "Press Enter to unload module and cleanup..."
sudo rmmod mychardev
make clean
rm -f test
echo "✓ Cleanup completed"
echo ""

echo "=== Test Completed ==="
```

### 3.5 使用说明

#### 编译驱动
```bash
make
```

#### 加载驱动
```bash
sudo insmod mychardev.ko
```

#### 查看设备
```bash
ls -l /dev/mychardev
cat /proc/devices | grep mychardev
```

#### 手动测试
```bash
# 写入数据
echo "Hello World" | sudo tee /dev/mychardev

# 读取数据
sudo cat /dev/mychardev
```

#### 编译并运行测试程序
```bash
gcc -o test test.c
sudo ./test
```

#### 查看内核日志
```bash
dmesg | tail -20
# 或者实时查看
sudo tail -f /var/log/kern.log
```

#### 卸载驱动
```bash
sudo rmmod mychardev
```

#### 一键测试脚本
```bash
chmod +x test.sh
./test.sh
```

### 3.6 常见问题与调试

#### 问题1：编译错误 - 找不到头文件
```bash
# 安装内核头文件
sudo apt-get install linux-headers-$(uname -r)  # Debian/Ubuntu
sudo yum install kernel-devel-$(uname -r)       # CentOS/RHEL
```

#### 问题2：权限不足
```bash
# 检查设备文件权限
ls -l /dev/mychardev

# 修改权限（如需要）
sudo chmod 666 /dev/mychardev
```

#### 问题3：设备已存在
```bash
# 卸载已加载的模块
sudo rmmod mychardev

# 查看模块是否卸载
lsmod | grep mychardev
```

#### 问题4：调试驱动
在代码中添加更多 printk 输出：
```c
printk(KERN_DEBUG "mychardev: Debug info: value=%d\n", value);
```

查看所有日志级别：
```bash
# 临时设置控制台日志级别
echo 8 > /proc/sys/kernel/printk

# 或者使用 dmesg 查看所有日志
dmesg -w  # 实时监控
```

### 3.7 扩展示例 - 带 ioctl 的版本

#### 添加 ioctl 命令定义
```c
#include <linux/ioctl.h>

/* 定义魔数 */
#define MYCHAR_IOC_MAGIC 'k'

/* 定义命令 */
#define MYCHAR_IOCRESET    _IO(MYCHAR_IOC_MAGIC, 0)
#define MYCHAR_IOCGETSIZE  _IOR(MYCHAR_IOC_MAGIC, 1, int)
#define MYCHAR_IOCSETSIZE  _IOW(MYCHAR_IOC_MAGIC, 2, int)

/* ioctl 函数实现 */
static long mychar_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct mychar_device *dev = filp->private_data;
    int ret = 0;
    int size;
    
    /* 检查魔数 */
    if (_IOC_TYPE(cmd) != MYCHAR_IOC_MAGIC)
        return -ENOTTY;
    
    switch (cmd) {
    case MYCHAR_IOCRESET:
        if (mutex_lock_interruptible(&dev->mutex))
            return -ERESTARTSYS;
        memset(dev->buffer, 0, BUFFER_SIZE);
        dev->buffer_size = 0;
        mutex_unlock(&dev->mutex);
        printk(KERN_INFO "mychardev: Buffer reset\n");
        break;
        
    case MYCHAR_IOCGETSIZE:
        size = dev->buffer_size;
        if (copy_to_user((int __user *)arg, &size, sizeof(size)))
            return -EFAULT;
        break;
        
    case MYCHAR_IOCSETSIZE:
        if (copy_from_user(&size, (int __user *)arg, sizeof(size)))
            return -EFAULT;
        if (size < 0 || size > BUFFER_SIZE)
            return -EINVAL;
        dev->buffer_size = size;
        break;
        
    default:
        return -ENOTTY;
    }
    
    return ret;
}
```

#### 更新 file_operations
```c
static struct file_operations mychar_fops = {
    .owner = THIS_MODULE,
    .open = mychar_open,
    .release = mychar_release,
    .read = mychar_read,
    .write = mychar_write,
    .llseek = mychar_llseek,
    .unlocked_ioctl = mychar_ioctl,  // 添加这一行
};
```

#### ioctl 测试程序
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define MYCHAR_IOC_MAGIC 'k'
#define MYCHAR_IOCRESET    _IO(MYCHAR_IOC_MAGIC, 0)
#define MYCHAR_IOCGETSIZE  _IOR(MYCHAR_IOC_MAGIC, 1, int)
#define MYCHAR_IOCSETSIZE  _IOW(MYCHAR_IOC_MAGIC, 2, int)

int main()
{
    int fd, size;
    
    fd = open("/dev/mychardev", O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }
    
    /* 获取当前大小 */
    if (ioctl(fd, MYCHAR_IOCGETSIZE, &size) == 0) {
        printf("Current buffer size: %d\n", size);
    }
    
    /* 重置缓冲区 */
    if (ioctl(fd, MYCHAR_IOCRESET) == 0) {
        printf("Buffer reset successfully\n");
    }
    
    close(fd);
    return 0;
}
```

### 3.8 高级功能示例

#### 等待队列实现（阻塞式读写）
```c
#include <linux/wait.h>

struct mychar_device {
    // ... 其他成员
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;
    int data_available;
};

/* 初始化等待队列 */
static int __init mychar_init(void)
{
    // ...
    init_waitqueue_head(&mydev->read_queue);
    init_waitqueue_head(&mydev->write_queue);
    mydev->data_available = 0;
    // ...
}

/* 阻塞式读取 */
static ssize_t mychar_read(struct file *filp, char __user *buf, 
                          size_t count, loff_t *f_pos)
{
    struct mychar_device *dev = filp->private_data;
    
    /* 等待数据可用 */
    if (wait_event_interruptible(dev->read_queue, dev->data_available))
        return -ERESTARTSYS;
    
    /* 读取数据 */
    // ... 读取实现
    
    dev->data_available = 0;
    wake_up_interruptible(&dev->write_queue);
    
    return bytes_read;
}
```

#### Poll/Select 支持
```c
#include <linux/poll.h>

static unsigned int mychar_poll(struct file *filp, poll_table *wait)
{
    struct mychar_device *dev = filp->private_data;
    unsigned int mask = 0;
    
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    if (dev->data_available)
        mask |= POLLIN | POLLRDNORM;  /* 可读 */
    
    if (dev->buffer_size < BUFFER_SIZE)
        mask |= POLLOUT | POLLWRNORM; /* 可写 */
    
    return mask;
}

/* 添加到 file_operations */
static struct file_operations mychar_fops = {
    // ...
    .poll = mychar_poll,
};
```

### 3.9 参考资料

#### 内核文档
- `/usr/src/linux/Documentation/driver-api/`
- Linux Device Drivers, 3rd Edition (LDD3)
- https://www.kernel.org/doc/html/latest/

#### 有用的命令
```bash
# 查看已加载模块
lsmod

# 查看模块信息
modinfo mychardev.ko

# 查看设备号
cat /proc/devices

# 查看设备类
ls /sys/class/

# 查看模块参数
ls /sys/module/mychardev/parameters/

# 内核符号表
cat /proc/kallsyms | grep mychar
```

#### 调试技巧
```bash
# 使用 ftrace 跟踪函数调用
echo function > /sys/kernel/debug/tracing/current_tracer
echo mychar_* > /sys/kernel/debug/tracing/set_ftrace_filter
cat /sys/kernel/debug/tracing/trace

# 使用 strace 跟踪系统调用
strace -e open,read,write,ioctl ./test

# 使用 GDB 调试内核模块（需要 KGDB 支持）
gdb vmlinux
(gdb) target remote /dev/ttyS0
```

---

## 附录：file_operations 结构体完整成员

```c
struct file_operations {
    struct module *owner;                    // 模块所有者
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
    int (*iterate) (struct file *, struct dir_context *);
    unsigned int (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct inode *, struct file *);
    int (*flush) (struct file *, fl_owner_t id);
    int (*release) (struct inode *, struct file *);
    int (*fsync) (struct file *, loff_t, loff_t, int datasync);
    int (*fasync) (int, struct file *, int);
    int (*lock) (struct file *, int, struct file_lock *);
    // ... 更多成员
};
```