# Linux驱动llseek知识点总结

## 第一章：llseek开发步骤

### 1.1 什么是llseek

`llseek` 是Linux字符设备驱动中用于调整文件读写位置的操作函数。当用户空间调用 `lseek()` 系统调用时，内核会调用驱动程序中注册的 `llseek` 函数来修改文件的当前偏移量。

### 1.2 llseek的作用

| 功能 | 说明 |
|------|------|
| 定位读写位置 | 允许用户随机访问设备中的数据 |
| 获取当前位置 | 通过 `SEEK_CUR` 偏移0可获取当前位置 |
| 获取设备大小 | 通过 `SEEK_END` 偏移0可获取设备总大小 |
| 支持随机访问 | 使设备支持类似文件的随机读写操作 |

### 1.3 llseek开发步骤

```
步骤一：确定设备是否需要支持seek操作
    ↓
步骤二：定义设备数据大小或边界
    ↓
步骤三：实现llseek回调函数
    ↓
步骤四：处理三种seek模式（SEEK_SET/SEEK_CUR/SEEK_END）
    ↓
步骤五：进行边界检查
    ↓
步骤六：更新并返回新的文件位置
    ↓
步骤七：注册到file_operations结构体
```

### 1.4 三种Seek模式

| 模式 | 宏定义 | 说明 |
|------|--------|------|
| `SEEK_SET` | 0 | 从文件开头计算偏移量 |
| `SEEK_CUR` | 1 | 从当前位置计算偏移量 |
| `SEEK_END` | 2 | 从文件末尾计算偏移量 |

### 1.5 llseek实现要点

1. **边界检查**：确保偏移量不会超出设备数据范围
2. **负值检查**：新位置不能为负数
3. **原子性**：在多线程环境下需要保护 `f_pos` 的修改
4. **返回值**：成功返回新的偏移量，失败返回负的错误码
5. **不支持seek**：如果设备不支持seek，设置 `.llseek = no_llseek`

### 1.6 常见错误码

| 错误码 | 说明 |
|--------|------|
| `-EINVAL` | 无效的whence参数或偏移量 |
| `-ESPIPE` | 设备不支持seek操作（如管道、FIFO） |
| `-EOVERFLOW` | 偏移量溢出 |

---

## 第二章：常用变量、结构体、函数

### 2.1 结构体

#### `struct file` - 文件对象结构体
```c
struct file {
    loff_t              f_pos;      /* 当前文件偏移量 */
    unsigned int        f_flags;    /* 文件打开标志 */
    fmode_t             f_mode;     /* 文件访问模式 */
    void                *private_data; /* 驱动私有数据 */
    const struct file_operations *f_op; /* 文件操作函数集 */
    /* ... 其他成员 ... */
};
```

**关键成员说明：**
- `f_pos`：当前文件读写位置，`llseek` 的核心操作对象
- `private_data`：驱动可用于存储设备相关信息

#### `struct file_operations` - 文件操作结构体
```c
struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    /* ... 其他成员 ... */
};
```

**llseek函数原型参数说明：**
| 参数 | 类型 | 说明 |
|------|------|------|
| `file` | `struct file *` | 文件对象指针 |
| `offset` | `loff_t` | 偏移量（可正可负） |
| `whence` | `int` | 起始位置（SEEK_SET/SEEK_CUR/SEEK_END） |
| 返回值 | `loff_t` | 新的文件位置，或负的错误码 |

#### `struct inode` - 索引节点结构体
```c
struct inode {
    loff_t              i_size;     /* 文件/设备大小 */
    dev_t               i_rdev;     /* 设备号 */
    /* ... 其他成员 ... */
};
```

---

### 2.2 内核预定义llseek函数

#### `generic_file_llseek` - 通用文件llseek实现
```c
loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：适用于普通文件的标准llseek实现
- **特点**：使用 `inode->i_size` 作为文件大小
- **适用场景**：后端有实际文件存储的设备

#### `noop_llseek` - 空操作llseek
```c
loff_t noop_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：返回当前位置，不进行任何实际操作
- **特点**：仅返回 `file->f_pos`，不修改位置
- **适用场景**：不关心文件位置的设备

#### `no_llseek` - 禁止llseek
```c
loff_t no_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：明确禁止seek操作
- **特点**：总是返回 `-ESPIPE` 错误
- **适用场景**：流式设备、管道类设备

#### `default_llseek` - 默认llseek实现
```c
loff_t default_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：内核默认的llseek实现
- **特点**：使用BKL（大内核锁）保护，已不推荐使用
- **注意**：如果未指定llseek，内核可能使用此函数

#### `fixed_size_llseek` - 固定大小llseek
```c
loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size);
```
- **用途**：用于固定大小设备的llseek实现
- **特点**：需要传入设备大小参数
- **适用场景**：EEPROM、Flash等固定大小存储设备

#### `no_seek_end_llseek` - 禁止SEEK_END的llseek
```c
loff_t no_seek_end_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：支持SEEK_SET和SEEK_CUR，但禁止SEEK_END
- **适用场景**：无法确定设备大小的场景

#### `no_seek_end_llseek_size` - 带大小限制的llseek
```c
loff_t no_seek_end_llseek_size(struct file *file, loff_t offset, 
                                int whence, loff_t size);
```
- **用途**：禁止SEEK_END，但可指定最大偏移量
- **适用场景**：有边界限制但无法从末尾计算的设备

---

### 2.3 辅助宏和类型

#### `loff_t` - 长偏移量类型
```c
typedef long long loff_t;
```
- **用途**：表示文件偏移量，支持大文件
- **范围**：64位有符号整数

#### `SEEK_SET`、`SEEK_CUR`、`SEEK_END` - Seek模式宏
```c
#define SEEK_SET    0   /* 从文件开头 */
#define SEEK_CUR    1   /* 从当前位置 */
#define SEEK_END    2   /* 从文件末尾 */
#define SEEK_DATA   3   /* 下一个数据区域（稀疏文件） */
#define SEEK_HOLE   4   /* 下一个空洞区域（稀疏文件） */
```

---

### 2.4 相关内核函数

#### `vfs_llseek` - VFS层llseek入口
```c
loff_t vfs_llseek(struct file *file, loff_t offset, int whence);
```
- **用途**：VFS层的llseek封装
- **特点**：内核内部调用，驱动一般不直接使用

#### `i_size_read` - 读取inode大小
```c
loff_t i_size_read(const struct inode *inode);
```
- **用途**：原子读取 `inode->i_size`
- **适用场景**：在llseek中获取设备/文件大小

#### `i_size_write` - 写入inode大小
```c
void i_size_write(struct inode *inode, loff_t i_size);
```
- **用途**：原子写入 `inode->i_size`
- **适用场景**：设备大小发生变化时更新

---

## 第三章：示例代码

### 3.1 基础llseek实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define DEVICE_NAME "llseek_demo"
#define BUF_SIZE    1024

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 设备数据结构 */
struct llseek_dev {
    char buffer[BUF_SIZE];
    size_t size;            /* 当前数据大小 */
    struct mutex lock;      /* 保护并发访问 */
};

static struct llseek_dev *my_dev;

/* llseek实现 */
static loff_t my_llseek(struct file *filp, loff_t offset, int whence)
{
    struct llseek_dev *dev = filp->private_data;
    loff_t new_pos;

    mutex_lock(&dev->lock);

    switch (whence) {
    case SEEK_SET:
        /* 从文件开头计算 */
        new_pos = offset;
        break;
    case SEEK_CUR:
        /* 从当前位置计算 */
        new_pos = filp->f_pos + offset;
        break;
    case SEEK_END:
        /* 从文件末尾计算 */
        new_pos = dev->size + offset;
        break;
    default:
        mutex_unlock(&dev->lock);
        return -EINVAL;
    }

    /* 边界检查 */
    if (new_pos < 0) {
        mutex_unlock(&dev->lock);
        return -EINVAL;
    }
    
    if (new_pos > BUF_SIZE) {
        mutex_unlock(&dev->lock);
        return -EINVAL;
    }

    /* 更新文件位置 */
    filp->f_pos = new_pos;
    
    mutex_unlock(&dev->lock);
    
    pr_info("llseek: new position = %lld\n", new_pos);
    return new_pos;
}

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = my_dev;
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct llseek_dev *dev = filp->private_data;
    ssize_t ret;

    mutex_lock(&dev->lock);

    if (*f_pos >= dev->size) {
        ret = 0;
        goto out;
    }

    if (*f_pos + count > dev->size)
        count = dev->size - *f_pos;

    if (copy_to_user(buf, dev->buffer + *f_pos, count)) {
        ret = -EFAULT;
        goto out;
    }

    *f_pos += count;
    ret = count;

out:
    mutex_unlock(&dev->lock);
    return ret;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct llseek_dev *dev = filp->private_data;
    ssize_t ret;

    mutex_lock(&dev->lock);

    if (*f_pos >= BUF_SIZE) {
        ret = -ENOSPC;
        goto out;
    }

    if (*f_pos + count > BUF_SIZE)
        count = BUF_SIZE - *f_pos;

    if (copy_from_user(dev->buffer + *f_pos, buf, count)) {
        ret = -EFAULT;
        goto out;
    }

    *f_pos += count;
    
    /* 更新数据大小 */
    if (*f_pos > dev->size)
        dev->size = *f_pos;

    ret = count;

out:
    mutex_unlock(&dev->lock);
    return ret;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = my_read,
    .write   = my_write,
    .llseek  = my_llseek,    /* 注册llseek函数 */
};

static int __init llseek_demo_init(void)
{
    int ret;

    my_dev = kzalloc(sizeof(*my_dev), GFP_KERNEL);
    if (!my_dev)
        return -ENOMEM;

    mutex_init(&my_dev->lock);
    
    /* 初始化测试数据 */
    strcpy(my_dev->buffer, "Hello, this is llseek demo!\n");
    my_dev->size = strlen(my_dev->buffer);

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);

    pr_info("llseek demo driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(my_dev);
    return ret;
}

static void __exit llseek_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(my_dev);
    pr_info("llseek demo driver unloaded\n");
}

module_init(llseek_demo_init);
module_exit(llseek_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("llseek demo driver");
```

---

### 3.2 使用fixed_size_llseek的实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "fixed_llseek_demo"
#define DEVICE_SIZE 4096    /* 固定设备大小 */

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;
static char device_buffer[DEVICE_SIZE];

/* 使用内核提供的fixed_size_llseek */
static loff_t my_llseek(struct file *filp, loff_t offset, int whence)
{
    return fixed_size_llseek(filp, offset, whence, DEVICE_SIZE);
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    if (*f_pos >= DEVICE_SIZE)
        return 0;

    if (*f_pos + count > DEVICE_SIZE)
        count = DEVICE_SIZE - *f_pos;

    if (copy_to_user(buf, device_buffer + *f_pos, count))
        return -EFAULT;

    *f_pos += count;
    return count;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    if (*f_pos >= DEVICE_SIZE)
        return -ENOSPC;

    if (*f_pos + count > DEVICE_SIZE)
        count = DEVICE_SIZE - *f_pos;

    if (copy_from_user(device_buffer + *f_pos, buf, count))
        return -EFAULT;

    *f_pos += count;
    return count;
}

static struct file_operations fops = {
    .owner  = THIS_MODULE,
    .read   = my_read,
    .write  = my_write,
    .llseek = my_llseek,
};

static int __init fixed_llseek_init(void)
{
    int ret;

    memset(device_buffer, 0, DEVICE_SIZE);

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);

    pr_info("Fixed size llseek demo loaded (size=%d)\n", DEVICE_SIZE);
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit fixed_llseek_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("Fixed size llseek demo unloaded\n");
}

module_init(fixed_llseek_init);
module_exit(fixed_llseek_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Fixed size llseek demo");
```

---

### 3.3 禁止llseek的实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define DEVICE_NAME "no_llseek_demo"

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 流式设备，只支持顺序读写，不支持seek */
static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    /* 模拟流式设备读取 */
    static const char *msg = "Stream data\n";
    size_t len = strlen(msg);

    if (count < len)
        len = count;

    if (copy_to_user(buf, msg, len))
        return -EFAULT;

    return len;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    /* 流式设备写入 */
    pr_info("Received %zu bytes\n", count);
    return count;
}

static struct file_operations fops = {
    .owner  = THIS_MODULE,
    .read   = my_read,
    .write  = my_write,
    .llseek = no_llseek,    /* 明确禁止seek操作 */
};

/* 设置nonseekable_open可在open时设置不可seek标志 */
static int my_open(struct inode *inode, struct file *filp)
{
    return nonseekable_open(inode, filp);
}

static struct file_operations fops_v2 = {
    .owner  = THIS_MODULE,
    .open   = my_open,      /* 使用nonseekable_open */
    .read   = my_read,
    .write  = my_write,
    .llseek = no_llseek,
};

static int __init no_llseek_init(void)
{
    int ret;

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);

    pr_info("No llseek demo loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit no_llseek_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("No llseek demo unloaded\n");
}

module_init(no_llseek_init);
module_exit(no_llseek_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("No llseek demo - stream device");
```

---

### 3.4 用户空间测试程序

```c
/* test_llseek.c - 用户空间测试程序 */
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define DEVICE_PATH "/dev/llseek_demo"

int main(void)
{
    int fd;
    char buf[256];
    off_t pos;
    ssize_t ret;

    /* 打开设备 */
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device");
        return -1;
    }

    printf("=== llseek Test ===\n\n");

    /* 测试1: 写入数据 */
    printf("Test 1: Writing data at position 0\n");
    ret = write(fd, "ABCDEFGHIJ", 10);
    printf("Written %zd bytes\n\n", ret);

    /* 测试2: SEEK_SET - 定位到开头 */
    printf("Test 2: SEEK_SET to position 0\n");
    pos = lseek(fd, 0, SEEK_SET);
    printf("Position after SEEK_SET(0): %ld\n", pos);
    ret = read(fd, buf, 5);
    buf[ret] = '\0';
    printf("Read: %s\n\n", buf);

    /* 测试3: SEEK_CUR - 从当前位置偏移 */
    printf("Test 3: SEEK_CUR with offset 2\n");
    pos = lseek(fd, 2, SEEK_CUR);
    printf("Position after SEEK_CUR(2): %ld\n", pos);
    ret = read(fd, buf, 3);
    buf[ret] = '\0';
    printf("Read: %s\n\n", buf);

    /* 测试4: SEEK_END - 定位到末尾 */
    printf("Test 4: SEEK_END with offset 0\n");
    pos = lseek(fd, 0, SEEK_END);
    printf("File size (position at end): %ld\n\n", pos);

    /* 测试5: SEEK_END - 从末尾倒退 */
    printf("Test 5: SEEK_END with offset -5\n");
    pos = lseek(fd, -5, SEEK_END);
    printf("Position after SEEK_END(-5): %ld\n", pos);
    ret = read(fd, buf, 5);
    buf[ret] = '\0';
    printf("Read last 5 bytes: %s\n\n", buf);

    /* 测试6: 获取当前位置 */
    printf("Test 6: Get current position (SEEK_CUR with 0)\n");
    pos = lseek(fd, 0, SEEK_CUR);
    printf("Current position: %ld\n\n", pos);

    /* 测试7: 无效偏移测试 */
    printf("Test 7: Invalid offset (negative position)\n");
    pos = lseek(fd, -100, SEEK_SET);
    if (pos == -1) {
        printf("Expected error: %s\n\n", strerror(errno));
    }

    close(fd);
    printf("=== Test Complete ===\n");
    return 0;
}
```

编译命令：
```bash
gcc -o test_llseek test_llseek.c
```

---

## 附录：头文件汇总

```c
#include <linux/fs.h>       // file_operations, loff_t, SEEK_SET等
#include <linux/uaccess.h>  // copy_to_user, copy_from_user
#include <linux/mutex.h>    // mutex保护f_pos访问
#include <linux/cdev.h>     // 字符设备相关
#include <linux/device.h>   // device_create等
```

---

## 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| lseek返回-ESPIPE | 设备设置了no_llseek | 实现自定义llseek或使用noop_llseek |
| lseek返回-EINVAL | whence参数错误或偏移越界 | 检查边界条件和whence值 |
| 读写位置不正确 | f_pos未正确更新 | 确保read/write正确更新*f_pos |
| 多线程访问错乱 | f_pos访问未加锁 | 使用mutex保护llseek和读写操作 |
| SEEK_END返回错误大小 | 设备大小未正确设置 | 正确维护设备数据大小变量 |

---

## llseek最佳实践

1. **明确设备特性**：根据设备特性决定是否支持seek
2. **边界检查**：始终检查新位置的合法性
3. **并发保护**：在多线程环境下保护f_pos的访问
4. **使用内核函数**：优先使用`fixed_size_llseek`等内核提供的函数
5. **明确禁止**：不支持seek的设备应使用`no_llseek`明确禁止
6. **错误处理**：返回合适的错误码便于用户空间处理
