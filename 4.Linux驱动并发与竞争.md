# Linux驱动并发与竞争

## 第一章：并发与竞争处理步骤

### 1.1 什么是并发与竞争

并发是指多个执行单元（进程、线程、中断）同时访问共享资源的情况。竞争（Race Condition）是指多个执行单元对共享资源的访问顺序不确定，导致程序行为不可预测。

### 1.2 Linux内核中的并发来源

| 并发来源 | 说明 |
|---------|------|
| 多进程/多线程 | 多个用户进程同时访问驱动 |
| 中断处理 | 硬件中断可能打断正在执行的代码 |
| 软中断/tasklet | 底半部处理与进程上下文并发 |
| 内核抢占 | 配置了抢占式内核时，高优先级任务抢占 |
| SMP多核 | 多CPU同时执行代码 |

### 1.3 临界区保护步骤

```
步骤一：识别共享资源
    ↓
步骤二：确定访问场景（进程/中断/软中断）
    ↓
步骤三：选择合适的同步机制
    ↓
步骤四：实现保护代码
    ↓
步骤五：验证死锁风险
```

### 1.4 同步机制选择指南

| 场景 | 推荐机制 | 原因 |
|------|---------|------|
| 简单计数器/标志位 | 原子操作 | 开销最小，无需加锁 |
| 进程上下文短临界区 | 自旋锁 | 开销小，忙等待适合短操作 |
| 进程上下文长临界区/可能睡眠 | 互斥锁 | 可睡眠，适合耗时操作 |
| 中断上下文 | spin_lock_irqsave | 禁止中断，防止死锁 |
| 读多写少场景 | 读写锁/RCU | 提高并发读性能 |
| 等待某个条件完成 | 完成量 | 专为同步等待设计 |
| 限制资源访问数量 | 信号量 | 计数型同步 |

### 1.5 死锁预防原则

1. **按固定顺序获取锁**：多锁场景下，所有代码路径按相同顺序加锁
2. **避免嵌套锁**：尽量减少锁的嵌套层次
3. **中断上下文不能使用可睡眠锁**：中断中禁用 `mutex_lock`、`down`
4. **持锁时间最小化**：只在必要时持有锁
5. **使用 `lockdep` 检测**：内核提供的死锁检测工具

---

## 第二章：常用函数速查

### 2.1 原子操作

#### `atomic_set` - 原子变量赋值
```c
void atomic_set(atomic_t *v, int i);
```

#### `atomic_read` - 原子变量读取
```c
int atomic_read(const atomic_t *v);
```

#### `atomic_inc` - 原子自增
```c
void atomic_inc(atomic_t *v);
```

#### `atomic_dec` - 原子自减
```c
void atomic_dec(atomic_t *v);
```

#### `atomic_add` - 原子加法
```c
void atomic_add(int i, atomic_t *v);
```

#### `atomic_sub` - 原子减法
```c
void atomic_sub(int i, atomic_t *v);
```

#### `atomic_dec_and_test` - 自减并测试是否为零
```c
int atomic_dec_and_test(atomic_t *v);  // 返回1表示结果为0
```

#### `atomic_inc_and_test` - 自增并测试是否为零
```c
int atomic_inc_and_test(atomic_t *v);
```

#### `atomic_cmpxchg` - 比较并交换
```c
int atomic_cmpxchg(atomic_t *v, int old, int new);
```

---

### 2.2 自旋锁

#### `spin_lock_init` - 初始化自旋锁
```c
void spin_lock_init(spinlock_t *lock);
// 静态初始化
spinlock_t lock = __SPIN_LOCK_UNLOCKED(lock);
// 或使用宏
DEFINE_SPINLOCK(lock);
```

#### `spin_lock` - 获取自旋锁
```c
void spin_lock(spinlock_t *lock);
```

#### `spin_unlock` - 释放自旋锁
```c
void spin_unlock(spinlock_t *lock);
```

#### `spin_lock_irq` - 获取锁并禁止本地中断
```c
void spin_lock_irq(spinlock_t *lock);
```

#### `spin_unlock_irq` - 释放锁并启用本地中断
```c
void spin_unlock_irq(spinlock_t *lock);
```

#### `spin_lock_irqsave` - 获取锁并保存中断状态
```c
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
```

#### `spin_unlock_irqrestore` - 释放锁并恢复中断状态
```c
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
```

#### `spin_trylock` - 尝试获取锁（非阻塞）
```c
int spin_trylock(spinlock_t *lock);  // 成功返回1，失败返回0
```

#### `spin_lock_bh` - 获取锁并禁止软中断
```c
void spin_lock_bh(spinlock_t *lock);
```

#### `spin_unlock_bh` - 释放锁并启用软中断
```c
void spin_unlock_bh(spinlock_t *lock);
```

---

### 2.3 互斥锁

#### `mutex_init` - 初始化互斥锁
```c
void mutex_init(struct mutex *lock);
// 静态初始化
DEFINE_MUTEX(lock);
```

#### `mutex_lock` - 获取互斥锁（可睡眠）
```c
void mutex_lock(struct mutex *lock);
```

#### `mutex_unlock` - 释放互斥锁
```c
void mutex_unlock(struct mutex *lock);
```

#### `mutex_trylock` - 尝试获取锁（非阻塞）
```c
int mutex_trylock(struct mutex *lock);  // 成功返回1，失败返回0
```

#### `mutex_lock_interruptible` - 可被信号中断的锁获取
```c
int mutex_lock_interruptible(struct mutex *lock);  // 被中断返回-EINTR
```

#### `mutex_is_locked` - 检查锁状态
```c
int mutex_is_locked(struct mutex *lock);
```

---

### 2.4 信号量

#### `sema_init` - 初始化信号量
```c
void sema_init(struct semaphore *sem, int val);
// 静态初始化
DEFINE_SEMAPHORE(sem);  // 初始值为1
```

#### `down` - 获取信号量（P操作，可睡眠）
```c
void down(struct semaphore *sem);
```

#### `up` - 释放信号量（V操作）
```c
void up(struct semaphore *sem);
```

#### `down_interruptible` - 可被信号中断的P操作
```c
int down_interruptible(struct semaphore *sem);  // 被中断返回非0
```

#### `down_trylock` - 尝试获取信号量（非阻塞）
```c
int down_trylock(struct semaphore *sem);  // 成功返回0，失败返回非0
```

#### `down_timeout` - 带超时的P操作
```c
int down_timeout(struct semaphore *sem, long jiffies);
```

---

### 2.5 读写锁

#### `rwlock_init` - 初始化读写锁
```c
void rwlock_init(rwlock_t *lock);
// 静态初始化
DEFINE_RWLOCK(lock);
```

#### `read_lock` - 获取读锁
```c
void read_lock(rwlock_t *lock);
```

#### `read_unlock` - 释放读锁
```c
void read_unlock(rwlock_t *lock);
```

#### `write_lock` - 获取写锁
```c
void write_lock(rwlock_t *lock);
```

#### `write_unlock` - 释放写锁
```c
void write_unlock(rwlock_t *lock);
```

#### `read_lock_irqsave` - 获取读锁并保存中断状态
```c
void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
```

#### `write_lock_irqsave` - 获取写锁并保存中断状态
```c
void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
```

---

### 2.6 读写信号量

#### `init_rwsem` - 初始化读写信号量
```c
void init_rwsem(struct rw_semaphore *sem);
// 静态初始化
DECLARE_RWSEM(sem);
```

#### `down_read` - 获取读信号量
```c
void down_read(struct rw_semaphore *sem);
```

#### `up_read` - 释放读信号量
```c
void up_read(struct rw_semaphore *sem);
```

#### `down_write` - 获取写信号量
```c
void down_write(struct rw_semaphore *sem);
```

#### `up_write` - 释放写信号量
```c
void up_write(struct rw_semaphore *sem);
```

---

### 2.7 完成量

#### `init_completion` - 初始化完成量
```c
void init_completion(struct completion *x);
// 静态初始化
DECLARE_COMPLETION(x);
```

#### `wait_for_completion` - 等待完成
```c
void wait_for_completion(struct completion *x);
```

#### `wait_for_completion_timeout` - 带超时等待
```c
unsigned long wait_for_completion_timeout(struct completion *x, 
                                          unsigned long timeout);
```

#### `wait_for_completion_interruptible` - 可中断等待
```c
int wait_for_completion_interruptible(struct completion *x);
```

#### `complete` - 唤醒一个等待者
```c
void complete(struct completion *x);
```

#### `complete_all` - 唤醒所有等待者
```c
void complete_all(struct completion *x);
```

#### `reinit_completion` - 重新初始化完成量
```c
void reinit_completion(struct completion *x);
```

---

### 2.8 RCU（Read-Copy-Update）

#### `rcu_read_lock` - 进入RCU读临界区
```c
void rcu_read_lock(void);
```

#### `rcu_read_unlock` - 退出RCU读临界区
```c
void rcu_read_unlock(void);
```

#### `synchronize_rcu` - 等待所有读者完成
```c
void synchronize_rcu(void);
```

#### `call_rcu` - 注册延迟回调
```c
void call_rcu(struct rcu_head *head, rcu_callback_t func);
```

#### `rcu_dereference` - 安全获取RCU保护的指针
```c
#define rcu_dereference(p)
```

#### `rcu_assign_pointer` - 安全更新RCU保护的指针
```c
#define rcu_assign_pointer(p, v)
```

---

### 2.9 位操作原子函数

#### `set_bit` - 原子设置位
```c
void set_bit(long nr, volatile unsigned long *addr);
```

#### `clear_bit` - 原子清除位
```c
void clear_bit(long nr, volatile unsigned long *addr);
```

#### `test_bit` - 测试位（非原子）
```c
int test_bit(long nr, const volatile unsigned long *addr);
```

#### `test_and_set_bit` - 测试并设置位
```c
int test_and_set_bit(long nr, volatile unsigned long *addr);
```

#### `test_and_clear_bit` - 测试并清除位
```c
int test_and_clear_bit(long nr, volatile unsigned long *addr);
```

---

## 第三章：示例代码

### 3.1 原子操作示例 - 设备打开计数

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/atomic.h>

#define DEVICE_NAME "atomic_demo"

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 原子变量：记录设备打开次数，限制只能被一个进程打开 */
static atomic_t device_available = ATOMIC_INIT(1);

static int my_open(struct inode *inode, struct file *filp)
{
    /* 原子自减并测试，如果结果为负则说明已被占用 */
    if (!atomic_dec_and_test(&device_available)) {
        atomic_inc(&device_available);  /* 恢复计数 */
        pr_err("Device already in use!\n");
        return -EBUSY;
    }
    
    pr_info("Device opened successfully\n");
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    /* 释放时原子自增 */
    atomic_inc(&device_available);
    pr_info("Device released\n");
    return 0;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .release = my_release,
};

static int __init atomic_demo_init(void)
{
    int ret;
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("Atomic demo driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit atomic_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("Atomic demo driver unloaded\n");
}

module_init(atomic_demo_init);
module_exit(atomic_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Atomic operation demo driver");
```

---

### 3.2 自旋锁示例 - 共享数据保护

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/spinlock.h>

#define DEVICE_NAME "spinlock_demo"
#define BUF_SIZE    256

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 共享数据结构 */
struct shared_data {
    spinlock_t lock;
    char buffer[BUF_SIZE];
    int data_len;
};

static struct shared_data *sdata;

static ssize_t my_read(struct file *filp, char __user *buf, 
                       size_t count, loff_t *f_pos)
{
    int ret;
    unsigned long flags;
    
    /* 使用自旋锁保护读操作 */
    spin_lock_irqsave(&sdata->lock, flags);
    
    if (sdata->data_len == 0) {
        spin_unlock_irqrestore(&sdata->lock, flags);
        return 0;
    }
    
    if (count > sdata->data_len)
        count = sdata->data_len;
    
    /* 注意：copy_to_user可能睡眠，实际应用中需要先复制到临时缓冲区 */
    /* 这里为演示目的简化处理 */
    ret = copy_to_user(buf, sdata->buffer, count);
    if (ret) {
        spin_unlock_irqrestore(&sdata->lock, flags);
        return -EFAULT;
    }
    
    spin_unlock_irqrestore(&sdata->lock, flags);
    
    return count;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    int ret;
    unsigned long flags;
    
    if (count > BUF_SIZE)
        count = BUF_SIZE;
    
    spin_lock_irqsave(&sdata->lock, flags);
    
    ret = copy_from_user(sdata->buffer, buf, count);
    if (ret) {
        spin_unlock_irqrestore(&sdata->lock, flags);
        return -EFAULT;
    }
    
    sdata->data_len = count;
    
    spin_unlock_irqrestore(&sdata->lock, flags);
    
    pr_info("Written %zu bytes\n", count);
    return count;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read  = my_read,
    .write = my_write,
};

static int __init spinlock_demo_init(void)
{
    int ret;
    
    /* 分配并初始化共享数据 */
    sdata = kzalloc(sizeof(*sdata), GFP_KERNEL);
    if (!sdata)
        return -ENOMEM;
    
    spin_lock_init(&sdata->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_alloc;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("Spinlock demo driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_alloc:
    kfree(sdata);
    return ret;
}

static void __exit spinlock_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(sdata);
    pr_info("Spinlock demo driver unloaded\n");
}

module_init(spinlock_demo_init);
module_exit(spinlock_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Spinlock demo driver");
```

---

### 3.3 互斥锁示例 - 长临界区保护

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/slab.h>

#define DEVICE_NAME "mutex_demo"
#define BUF_SIZE    4096

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 使用互斥锁保护的设备数据 */
struct device_data {
    struct mutex lock;
    char *buffer;
    size_t size;
};

static struct device_data *dev_data;

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = dev_data;
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct device_data *data = filp->private_data;
    ssize_t ret;
    
    /* 互斥锁可以睡眠，适合较长的临界区 */
    if (mutex_lock_interruptible(&data->lock))
        return -ERESTARTSYS;
    
    if (*f_pos >= data->size) {
        ret = 0;
        goto out;
    }
    
    if (*f_pos + count > data->size)
        count = data->size - *f_pos;
    
    if (copy_to_user(buf, data->buffer + *f_pos, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    *f_pos += count;
    ret = count;
    
out:
    mutex_unlock(&data->lock);
    return ret;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct device_data *data = filp->private_data;
    ssize_t ret;
    
    if (mutex_lock_interruptible(&data->lock))
        return -ERESTARTSYS;
    
    if (*f_pos >= BUF_SIZE) {
        ret = -ENOSPC;
        goto out;
    }
    
    if (*f_pos + count > BUF_SIZE)
        count = BUF_SIZE - *f_pos;
    
    if (copy_from_user(data->buffer + *f_pos, buf, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    *f_pos += count;
    if (*f_pos > data->size)
        data->size = *f_pos;
    
    ret = count;
    
out:
    mutex_unlock(&data->lock);
    return ret;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open  = my_open,
    .read  = my_read,
    .write = my_write,
};

static int __init mutex_demo_init(void)
{
    int ret;
    
    dev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);
    if (!dev_data)
        return -ENOMEM;
    
    dev_data->buffer = kzalloc(BUF_SIZE, GFP_KERNEL);
    if (!dev_data->buffer) {
        ret = -ENOMEM;
        goto fail_buf;
    }
    
    mutex_init(&dev_data->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("Mutex demo driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(dev_data->buffer);
fail_buf:
    kfree(dev_data);
    return ret;
}

static void __exit mutex_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(dev_data->buffer);
    kfree(dev_data);
    pr_info("Mutex demo driver unloaded\n");
}

module_init(mutex_demo_init);
module_exit(mutex_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Mutex demo driver");
```

---

### 3.4 完成量示例 - 同步等待

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/completion.h>
#include <linux/kthread.h>
#include <linux/delay.h>

#define DEVICE_NAME "completion_demo"

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

static DECLARE_COMPLETION(data_ready);
static struct task_struct *worker_thread;
static int data_value = 0;

/* 工作线程：模拟数据准备过程 */
static int worker_func(void *arg)
{
    while (!kthread_should_stop()) {
        /* 模拟耗时的数据准备工作 */
        msleep(2000);
        
        data_value++;
        pr_info("Data prepared: %d\n", data_value);
        
        /* 通知等待者数据已准备好 */
        complete(&data_ready);
    }
    
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    int ret;
    char tmp[32];
    
    pr_info("Waiting for data...\n");
    
    /* 等待数据准备完成，可被信号中断 */
    ret = wait_for_completion_interruptible(&data_ready);
    if (ret)
        return -ERESTARTSYS;
    
    /* 重新初始化完成量，以便下次使用 */
    reinit_completion(&data_ready);
    
    ret = snprintf(tmp, sizeof(tmp), "%d\n", data_value);
    if (count < ret)
        ret = count;
    
    if (copy_to_user(buf, tmp, ret))
        return -EFAULT;
    
    return ret;
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read  = my_read,
};

static int __init completion_demo_init(void)
{
    int ret;
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    /* 创建工作线程 */
    worker_thread = kthread_run(worker_func, NULL, "completion_worker");
    if (IS_ERR(worker_thread)) {
        ret = PTR_ERR(worker_thread);
        goto fail_thread;
    }
    
    pr_info("Completion demo driver loaded\n");
    return 0;

fail_thread:
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit completion_demo_exit(void)
{
    kthread_stop(worker_thread);
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("Completion demo driver unloaded\n");
}

module_init(completion_demo_init);
module_exit(completion_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Completion demo driver");
```

---

### 3.5 综合示例 - 多种同步机制配合使用

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include <linux/spinlock.h>
#include <linux/atomic.h>
#include <linux/wait.h>
#include <linux/sched.h>

#define DEVICE_NAME "sync_demo"
#define BUF_SIZE    1024

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct sync_device {
    /* 原子变量：统计访问次数 */
    atomic_t access_count;
    
    /* 互斥锁：保护长时间的读写操作 */
    struct mutex io_lock;
    
    /* 自旋锁：保护状态标志的快速访问 */
    spinlock_t state_lock;
    
    /* 等待队列：用于阻塞等待 */
    wait_queue_head_t wait_queue;
    
    /* 数据缓冲区 */
    char buffer[BUF_SIZE];
    size_t data_len;
    
    /* 状态标志 */
    int data_available;
};

static struct sync_device *sync_dev;

static int my_open(struct inode *inode, struct file *filp)
{
    /* 原子增加访问计数 */
    atomic_inc(&sync_dev->access_count);
    pr_info("Device opened, total access: %d\n", 
            atomic_read(&sync_dev->access_count));
    
    filp->private_data = sync_dev;
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    pr_info("Device closed\n");
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct sync_device *dev = filp->private_data;
    unsigned long flags;
    ssize_t ret;
    
    /* 获取互斥锁保护整个读操作 */
    if (mutex_lock_interruptible(&dev->io_lock))
        return -ERESTARTSYS;
    
    /* 等待数据可用 */
    while (1) {
        spin_lock_irqsave(&dev->state_lock, flags);
        if (dev->data_available) {
            spin_unlock_irqrestore(&dev->state_lock, flags);
            break;
        }
        spin_unlock_irqrestore(&dev->state_lock, flags);
        
        mutex_unlock(&dev->io_lock);
        
        /* 如果是非阻塞模式，直接返回 */
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        /* 等待数据可用 */
        if (wait_event_interruptible(dev->wait_queue, dev->data_available))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->io_lock))
            return -ERESTARTSYS;
    }
    
    /* 读取数据 */
    if (count > dev->data_len)
        count = dev->data_len;
    
    if (copy_to_user(buf, dev->buffer, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    /* 更新状态 */
    spin_lock_irqsave(&dev->state_lock, flags);
    dev->data_len = 0;
    dev->data_available = 0;
    spin_unlock_irqrestore(&dev->state_lock, flags);
    
    ret = count;
    
out:
    mutex_unlock(&dev->io_lock);
    return ret;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct sync_device *dev = filp->private_data;
    unsigned long flags;
    ssize_t ret;
    
    if (count > BUF_SIZE)
        count = BUF_SIZE;
    
    /* 获取互斥锁保护整个写操作 */
    if (mutex_lock_interruptible(&dev->io_lock))
        return -ERESTARTSYS;
    
    if (copy_from_user(dev->buffer, buf, count)) {
        ret = -EFAULT;
        goto out;
    }
    
    /* 使用自旋锁更新状态 */
    spin_lock_irqsave(&dev->state_lock, flags);
    dev->data_len = count;
    dev->data_available = 1;
    spin_unlock_irqrestore(&dev->state_lock, flags);
    
    /* 唤醒等待的读进程 */
    wake_up_interruptible(&dev->wait_queue);
    
    ret = count;
    
out:
    mutex_unlock(&dev->io_lock);
    return ret;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .release = my_release,
    .read    = my_read,
    .write   = my_write,
};

static int __init sync_demo_init(void)
{
    int ret;
    
    sync_dev = kzalloc(sizeof(*sync_dev), GFP_KERNEL);
    if (!sync_dev)
        return -ENOMEM;
    
    /* 初始化所有同步原语 */
    atomic_set(&sync_dev->access_count, 0);
    mutex_init(&sync_dev->io_lock);
    spin_lock_init(&sync_dev->state_lock);
    init_waitqueue_head(&sync_dev->wait_queue);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("Sync demo driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(sync_dev);
    return ret;
}

static void __exit sync_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(sync_dev);
    pr_info("Sync demo driver unloaded\n");
}

module_init(sync_demo_init);
module_exit(sync_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Comprehensive sync mechanism demo driver");
```

---

## 附录：头文件汇总

```c
#include <linux/atomic.h>       // 原子操作: atomic_t, atomic_inc, atomic_dec
#include <linux/spinlock.h>     // 自旋锁: spinlock_t, spin_lock, spin_unlock
#include <linux/mutex.h>        // 互斥锁: mutex, mutex_init, mutex_lock
#include <linux/semaphore.h>    // 信号量: semaphore, down, up
#include <linux/rwlock.h>       // 读写锁: rwlock_t
#include <linux/rwsem.h>        // 读写信号量: rw_semaphore
#include <linux/completion.h>   // 完成量: completion, wait_for_completion
#include <linux/rcupdate.h>     // RCU: rcu_read_lock, synchronize_rcu
#include <linux/wait.h>         // 等待队列: wait_queue_head_t, wait_event
```

---

## 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| 系统死锁 | 嵌套锁顺序不一致 | 统一加锁顺序 |
| 内核崩溃 | 中断中使用了可睡眠锁 | 改用spin_lock_irqsave |
| 性能低下 | 锁粒度太大 | 拆分为细粒度锁 |
| 数据损坏 | 临界区保护不完整 | 检查所有访问点 |
| BUG: sleeping function called | 原子上下文中睡眠 | 检查是否在持有自旋锁时调用了可能睡眠的函数 |
