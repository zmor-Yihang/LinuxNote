# Linux驱动ioctl知识点总结

## 第一章：ioctl开发步骤

### 1.1 什么是ioctl

`ioctl`（Input/Output Control）是Linux设备驱动中用于设备控制的系统调用。它提供了一种除读写之外的设备控制机制，允许用户空间程序向设备发送控制命令、获取设备状态或配置设备参数。

### 1.2 ioctl的作用

| 功能 | 说明 |
|------|------|
| 设备配置 | 设置波特率、分辨率、工作模式等参数 |
| 状态查询 | 获取设备状态、版本信息、能力等 |
| 硬件控制 | 复位、启动、停止等控制操作 |
| 数据交换 | 传递结构化数据（读写操作不方便时） |

### 1.3 ioctl开发步骤

```
步骤一：定义ioctl命令号
    ↓
步骤二：确定命令的数据传输方向（无/读/写/读写）
    ↓
步骤三：定义传输数据的结构体（如需要）
    ↓
步骤四：实现unlocked_ioctl回调函数
    ↓
步骤五：处理各个命令的逻辑
    ↓
步骤六：进行用户空间数据拷贝（如需要）
    ↓
步骤七：注册到file_operations结构体
```

### 1.4 ioctl命令号构成

ioctl命令号是一个32位整数，由四部分组成：

```
| 方向(2bit) | 数据大小(14bit) | 魔数(8bit) | 命令序号(8bit) |
|    31-30   |      29-16      |    15-8    |      7-0       |
```

| 字段 | 位数 | 说明 |
|------|------|------|
| 方向（dir） | 2 | 数据传输方向：无/读/写/读写 |
| 大小（size） | 14 | 数据大小（字节） |
| 类型（type） | 8 | 魔数，用于区分不同驱动 |
| 序号（nr） | 8 | 命令序号，0-255 |

### 1.5 命令号定义宏

| 宏 | 说明 | 用法 |
|----|------|------|
| `_IO(type, nr)` | 无数据传输 | 简单控制命令 |
| `_IOR(type, nr, datatype)` | 从驱动读取数据 | 获取设备信息 |
| `_IOW(type, nr, datatype)` | 向驱动写入数据 | 配置设备参数 |
| `_IOWR(type, nr, datatype)` | 双向数据传输 | 读写同时进行 |

### 1.6 ioctl实现要点

1. **魔数选择**：选择未被占用的魔数，可参考 `Documentation/userspace-api/ioctl/ioctl-number.rst`
2. **参数校验**：验证用户传入的参数合法性
3. **权限检查**：必要时检查调用者权限（`capable()`）
4. **数据拷贝**：使用 `copy_from_user/copy_to_user` 安全拷贝数据
5. **错误处理**：返回合适的错误码
6. **兼容性**：考虑32位应用在64位内核上运行的兼容性问题

### 1.7 常见错误码

| 错误码 | 说明 |
|--------|------|
| `-ENOTTY` | 不支持的ioctl命令 |
| `-EINVAL` | 无效的参数 |
| `-EFAULT` | 用户空间地址无效 |
| `-EPERM` | 权限不足 |
| `-EBUSY` | 设备忙 |

---

## 第二章：常用变量、结构体、函数

### 2.1 结构体

#### `struct file_operations` - 文件操作结构体（ioctl相关）
```c
struct file_operations {
    struct module *owner;
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    /* ... 其他成员 ... */
};
```

**ioctl函数原型参数说明：**
| 参数 | 类型 | 说明 |
|------|------|------|
| `file` | `struct file *` | 文件对象指针 |
| `cmd` | `unsigned int` | ioctl命令号 |
| `arg` | `unsigned long` | 用户传入的参数（值或指针） |
| 返回值 | `long` | 成功返回0或正值，失败返回负的错误码 |

**两种ioctl回调的区别：**
| 回调函数 | 说明 |
|----------|------|
| `unlocked_ioctl` | 标准ioctl实现，不持有BKL |
| `compat_ioctl` | 32位应用程序在64位内核上的兼容处理 |

#### `struct file` - 文件对象结构体
```c
struct file {
    void                *private_data; /* 驱动私有数据 */
    const struct file_operations *f_op;
    unsigned int        f_flags;       /* 文件打开标志 */
    fmode_t             f_mode;        /* 文件访问模式 */
    /* ... 其他成员 ... */
};
```

---

### 2.2 命令号定义宏

#### `_IO` - 定义无数据传输命令
```c
#define _IO(type, nr)   _IOC(_IOC_NONE, (type), (nr), 0)
```
- **用途**：定义不需要传输数据的简单控制命令
- **示例**：`#define MY_RESET _IO('M', 0)`

#### `_IOR` - 定义读取数据命令
```c
#define _IOR(type, nr, size)  _IOC(_IOC_READ, (type), (nr), sizeof(size))
```
- **用途**：从内核空间读取数据到用户空间
- **示例**：`#define MY_GET_STATUS _IOR('M', 1, int)`

#### `_IOW` - 定义写入数据命令
```c
#define _IOW(type, nr, size)  _IOC(_IOC_WRITE, (type), (nr), sizeof(size))
```
- **用途**：从用户空间写入数据到内核空间
- **示例**：`#define MY_SET_CONFIG _IOW('M', 2, struct my_config)`

#### `_IOWR` - 定义读写数据命令
```c
#define _IOWR(type, nr, size) _IOC(_IOC_READ|_IOC_WRITE, (type), (nr), sizeof(size))
```
- **用途**：双向数据传输
- **示例**：`#define MY_XFER _IOWR('M', 3, struct my_xfer)`

---

### 2.3 命令号解析宏

#### `_IOC_DIR` - 获取命令的数据方向
```c
#define _IOC_DIR(nr)    (((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
```
- **返回值**：`_IOC_NONE`、`_IOC_READ`、`_IOC_WRITE` 或其组合

#### `_IOC_TYPE` - 获取命令的魔数
```c
#define _IOC_TYPE(nr)   (((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
```
- **用途**：验证命令是否属于本驱动

#### `_IOC_NR` - 获取命令序号
```c
#define _IOC_NR(nr)     (((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
```
- **用途**：获取命令的序号部分

#### `_IOC_SIZE` - 获取数据大小
```c
#define _IOC_SIZE(nr)   (((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
```
- **用途**：获取传输数据的大小

---

### 2.4 数据传输方向常量

```c
#define _IOC_NONE   0U    /* 无数据传输 */
#define _IOC_WRITE  1U    /* 用户写入数据到内核 */
#define _IOC_READ   2U    /* 用户从内核读取数据 */
```

---

### 2.5 访问控制函数

#### `access_ok` - 验证用户空间地址
```c
int access_ok(const void __user *addr, size_t size);
```
- **用途**：验证用户空间地址是否可访问
- **返回值**：有效返回非0，无效返回0
- **注意**：新内核版本已简化，不再需要type参数

#### `copy_from_user` - 从用户空间拷贝数据
```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);
```
- **用途**：安全地从用户空间拷贝数据到内核空间
- **返回值**：未能拷贝的字节数，成功返回0

#### `copy_to_user` - 拷贝数据到用户空间
```c
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
```
- **用途**：安全地从内核空间拷贝数据到用户空间
- **返回值**：未能拷贝的字节数，成功返回0

#### `get_user` - 获取用户空间简单变量
```c
int get_user(x, ptr);
```
- **用途**：从用户空间读取1/2/4/8字节的简单变量
- **返回值**：成功返回0，失败返回-EFAULT
- **示例**：`get_user(val, (int __user *)arg)`

#### `put_user` - 写入用户空间简单变量
```c
int put_user(x, ptr);
```
- **用途**：向用户空间写入1/2/4/8字节的简单变量
- **返回值**：成功返回0，失败返回-EFAULT
- **示例**：`put_user(val, (int __user *)arg)`

---

### 2.6 权限检查函数

#### `capable` - 检查进程能力
```c
bool capable(int cap);
```
- **用途**：检查当前进程是否具有指定的能力
- **常用能力**：
  - `CAP_SYS_ADMIN`：系统管理能力
  - `CAP_SYS_RAWIO`：原始I/O能力
  - `CAP_NET_ADMIN`：网络管理能力

---

## 第三章：示例代码

### 3.1 ioctl命令定义头文件

```c
/* my_ioctl.h - 驱动和应用程序共用的头文件 */
#ifndef _MY_IOCTL_H
#define _MY_IOCTL_H

#include <linux/ioctl.h>

/* 魔数定义 - 选择一个未被占用的字符 */
#define MY_IOC_MAGIC  'M'

/* 设备配置结构体 */
struct my_config {
    int mode;           /* 工作模式 */
    int speed;          /* 速度设置 */
    int flags;          /* 标志位 */
};

/* 设备状态结构体 */
struct my_status {
    int state;          /* 当前状态 */
    int error_count;    /* 错误计数 */
    unsigned long uptime; /* 运行时间 */
};

/* 数据传输结构体 */
struct my_transfer {
    void __user *buf;   /* 数据缓冲区 */
    size_t len;         /* 数据长度 */
    int direction;      /* 传输方向 */
};

/* ioctl命令定义 */
#define MY_IOC_RESET      _IO(MY_IOC_MAGIC, 0)                    /* 复位设备 */
#define MY_IOC_GET_STATUS _IOR(MY_IOC_MAGIC, 1, struct my_status) /* 获取状态 */
#define MY_IOC_SET_CONFIG _IOW(MY_IOC_MAGIC, 2, struct my_config) /* 设置配置 */
#define MY_IOC_GET_CONFIG _IOR(MY_IOC_MAGIC, 3, struct my_config) /* 获取配置 */
#define MY_IOC_TRANSFER   _IOWR(MY_IOC_MAGIC, 4, struct my_transfer) /* 数据传输 */
#define MY_IOC_GET_VERSION _IOR(MY_IOC_MAGIC, 5, int)             /* 获取版本 */
#define MY_IOC_SET_MODE   _IOW(MY_IOC_MAGIC, 6, int)              /* 设置模式 */

/* 命令序号最大值 */
#define MY_IOC_MAXNR  6

#endif /* _MY_IOCTL_H */
```

---

### 3.2 基础ioctl驱动实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#include "my_ioctl.h"

#define DEVICE_NAME "ioctl_demo"
#define DRIVER_VERSION 0x010203  /* v1.2.3 */

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

/* 设备私有数据 */
struct my_device {
    struct my_config config;
    struct my_status status;
    struct mutex lock;
};

static struct my_device *my_dev;

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = my_dev;
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    return 0;
}

/* ioctl实现 */
static long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct my_device *dev = filp->private_data;
    int ret = 0;
    int tmp;
    struct my_config config;
    struct my_status status;
    void __user *argp = (void __user *)arg;

    /* 验证命令的魔数 */
    if (_IOC_TYPE(cmd) != MY_IOC_MAGIC) {
        pr_err("Invalid magic number\n");
        return -ENOTTY;
    }

    /* 验证命令序号 */
    if (_IOC_NR(cmd) > MY_IOC_MAXNR) {
        pr_err("Invalid command number\n");
        return -ENOTTY;
    }

    /* 验证用户空间地址（如果需要数据传输） */
    if (_IOC_DIR(cmd) & _IOC_READ) {
        if (!access_ok(argp, _IOC_SIZE(cmd)))
            return -EFAULT;
    }
    if (_IOC_DIR(cmd) & _IOC_WRITE) {
        if (!access_ok(argp, _IOC_SIZE(cmd)))
            return -EFAULT;
    }

    mutex_lock(&dev->lock);

    switch (cmd) {
    case MY_IOC_RESET:
        /* 复位设备 - 无数据传输 */
        pr_info("Device reset\n");
        memset(&dev->config, 0, sizeof(dev->config));
        dev->status.state = 0;
        dev->status.error_count = 0;
        break;

    case MY_IOC_GET_STATUS:
        /* 获取设备状态 */
        dev->status.uptime = jiffies_to_msecs(jiffies);
        if (copy_to_user(argp, &dev->status, sizeof(dev->status))) {
            ret = -EFAULT;
            break;
        }
        pr_info("Get status: state=%d, errors=%d\n", 
                dev->status.state, dev->status.error_count);
        break;

    case MY_IOC_SET_CONFIG:
        /* 设置设备配置 */
        if (copy_from_user(&config, argp, sizeof(config))) {
            ret = -EFAULT;
            break;
        }
        /* 参数校验 */
        if (config.mode < 0 || config.mode > 3) {
            ret = -EINVAL;
            break;
        }
        dev->config = config;
        pr_info("Set config: mode=%d, speed=%d, flags=0x%x\n",
                config.mode, config.speed, config.flags);
        break;

    case MY_IOC_GET_CONFIG:
        /* 获取设备配置 */
        if (copy_to_user(argp, &dev->config, sizeof(dev->config))) {
            ret = -EFAULT;
            break;
        }
        break;

    case MY_IOC_GET_VERSION:
        /* 获取驱动版本 - 使用put_user传递简单值 */
        tmp = DRIVER_VERSION;
        if (put_user(tmp, (int __user *)arg)) {
            ret = -EFAULT;
            break;
        }
        pr_info("Get version: 0x%06x\n", tmp);
        break;

    case MY_IOC_SET_MODE:
        /* 设置模式 - 使用get_user获取简单值 */
        if (get_user(tmp, (int __user *)arg)) {
            ret = -EFAULT;
            break;
        }
        if (tmp < 0 || tmp > 3) {
            ret = -EINVAL;
            break;
        }
        dev->config.mode = tmp;
        pr_info("Set mode: %d\n", tmp);
        break;

    default:
        ret = -ENOTTY;
        break;
    }

    mutex_unlock(&dev->lock);
    return ret;
}

static struct file_operations fops = {
    .owner          = THIS_MODULE,
    .open           = my_open,
    .release        = my_release,
    .unlocked_ioctl = my_ioctl,     /* 注册ioctl函数 */
};

static int __init ioctl_demo_init(void)
{
    int ret;

    /* 分配设备数据 */
    my_dev = kzalloc(sizeof(*my_dev), GFP_KERNEL);
    if (!my_dev)
        return -ENOMEM;

    mutex_init(&my_dev->lock);
    
    /* 初始化默认配置 */
    my_dev->config.mode = 0;
    my_dev->config.speed = 115200;
    my_dev->status.state = 1;  /* 就绪状态 */

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);

    pr_info("ioctl demo driver loaded, major=%d\n", MAJOR(dev_num));
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(my_dev);
    return ret;
}

static void __exit ioctl_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(my_dev);
    pr_info("ioctl demo driver unloaded\n");
}

module_init(ioctl_demo_init);
module_exit(ioctl_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("ioctl demo driver");
```

---

### 3.3 带权限检查的ioctl实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/capability.h>

#define DEVICE_NAME "secure_ioctl"
#define SECURE_MAGIC 'S'

/* 命令定义 */
#define SECURE_GET_INFO   _IOR(SECURE_MAGIC, 0, int)    /* 普通用户可用 */
#define SECURE_SET_PARAM  _IOW(SECURE_MAGIC, 1, int)    /* 需要CAP_SYS_ADMIN */
#define SECURE_RESET      _IO(SECURE_MAGIC, 2)          /* 需要CAP_SYS_ADMIN */
#define SECURE_RAW_ACCESS _IOWR(SECURE_MAGIC, 3, long)  /* 需要CAP_SYS_RAWIO */

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;
static int device_param = 100;

static long secure_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    int tmp;
    long val;

    switch (cmd) {
    case SECURE_GET_INFO:
        /* 普通命令，无需特殊权限 */
        tmp = device_param;
        if (put_user(tmp, (int __user *)arg))
            return -EFAULT;
        break;

    case SECURE_SET_PARAM:
        /* 需要管理员权限 */
        if (!capable(CAP_SYS_ADMIN)) {
            pr_warn("Permission denied: need CAP_SYS_ADMIN\n");
            return -EPERM;
        }
        if (get_user(tmp, (int __user *)arg))
            return -EFAULT;
        device_param = tmp;
        pr_info("Parameter set to %d (by privileged user)\n", tmp);
        break;

    case SECURE_RESET:
        /* 需要管理员权限 */
        if (!capable(CAP_SYS_ADMIN))
            return -EPERM;
        device_param = 100;
        pr_info("Device reset (by privileged user)\n");
        break;

    case SECURE_RAW_ACCESS:
        /* 需要原始I/O权限 */
        if (!capable(CAP_SYS_RAWIO)) {
            pr_warn("Permission denied: need CAP_SYS_RAWIO\n");
            return -EPERM;
        }
        if (copy_from_user(&val, (void __user *)arg, sizeof(val)))
            return -EFAULT;
        /* 处理原始数据 */
        val = val * 2;  /* 示例操作 */
        if (copy_to_user((void __user *)arg, &val, sizeof(val)))
            return -EFAULT;
        break;

    default:
        return -ENOTTY;
    }

    return 0;
}

static struct file_operations fops = {
    .owner          = THIS_MODULE,
    .unlocked_ioctl = secure_ioctl,
};

static int __init secure_ioctl_init(void)
{
    int ret;

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    pr_info("Secure ioctl driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit secure_ioctl_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("Secure ioctl driver unloaded\n");
}

module_init(secure_ioctl_init);
module_exit(secure_ioctl_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Secure ioctl demo with capability check");
```

---

### 3.4 32/64位兼容ioctl实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/compat.h>

#define DEVICE_NAME "compat_ioctl"
#define COMPAT_MAGIC 'C'

/* 64位结构体 */
struct data_64 {
    long value;
    void *ptr;
    size_t size;
};

/* 32位兼容结构体 */
struct compat_data_32 {
    s32 value;           /* 32位long */
    compat_uptr_t ptr;   /* 32位指针 */
    compat_size_t size;  /* 32位size_t */
};

#define COMPAT_GET_DATA  _IOR(COMPAT_MAGIC, 0, struct data_64)
#define COMPAT_SET_DATA  _IOW(COMPAT_MAGIC, 1, struct data_64)

/* 32位ioctl命令号 */
#define COMPAT32_GET_DATA  _IOR(COMPAT_MAGIC, 0, struct compat_data_32)
#define COMPAT32_SET_DATA  _IOW(COMPAT_MAGIC, 1, struct compat_data_32)

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;
static struct data_64 device_data;

/* 64位ioctl */
static long native_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct data_64 data;

    switch (cmd) {
    case COMPAT_GET_DATA:
        if (copy_to_user((void __user *)arg, &device_data, sizeof(device_data)))
            return -EFAULT;
        break;

    case COMPAT_SET_DATA:
        if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
            return -EFAULT;
        device_data = data;
        pr_info("Set data: value=%ld, ptr=%p, size=%zu\n",
                data.value, data.ptr, data.size);
        break;

    default:
        return -ENOTTY;
    }

    return 0;
}

#ifdef CONFIG_COMPAT
/* 32位兼容ioctl */
static long compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct compat_data_32 data32;
    struct data_64 data64;

    switch (cmd) {
    case COMPAT32_GET_DATA:
        /* 将64位数据转换为32位 */
        data32.value = (s32)device_data.value;
        data32.ptr = ptr_to_compat(device_data.ptr);
        data32.size = (compat_size_t)device_data.size;
        
        if (copy_to_user((void __user *)arg, &data32, sizeof(data32)))
            return -EFAULT;
        break;

    case COMPAT32_SET_DATA:
        /* 从32位数据转换为64位 */
        if (copy_from_user(&data32, (void __user *)arg, sizeof(data32)))
            return -EFAULT;
        
        data64.value = data32.value;
        data64.ptr = compat_ptr(data32.ptr);
        data64.size = data32.size;
        device_data = data64;
        
        pr_info("Set data (compat): value=%ld, size=%zu\n",
                data64.value, data64.size);
        break;

    default:
        return -ENOTTY;
    }

    return 0;
}
#endif

static struct file_operations fops = {
    .owner          = THIS_MODULE,
    .unlocked_ioctl = native_ioctl,
#ifdef CONFIG_COMPAT
    .compat_ioctl   = compat_ioctl,  /* 32位兼容 */
#endif
};

static int __init compat_ioctl_init(void)
{
    int ret;

    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;

    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;

    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }

    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    pr_info("Compat ioctl driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
    return ret;
}

static void __exit compat_ioctl_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    pr_info("Compat ioctl driver unloaded\n");
}

module_init(compat_ioctl_init);
module_exit(compat_ioctl_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("32/64 bit compatible ioctl demo");
```

---

### 3.5 用户空间测试程序

```c
/* test_ioctl.c - 用户空间测试程序 */
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/ioctl.h>

/* 包含与驱动共用的头文件 */
#include "my_ioctl.h"

#define DEVICE_PATH "/dev/ioctl_demo"

int main(void)
{
    int fd;
    int ret;
    int version;
    struct my_config config;
    struct my_status status;

    /* 打开设备 */
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device");
        return -1;
    }

    printf("=== ioctl Test ===\n\n");

    /* 测试1: 获取驱动版本 */
    printf("Test 1: Get driver version\n");
    ret = ioctl(fd, MY_IOC_GET_VERSION, &version);
    if (ret < 0) {
        perror("ioctl GET_VERSION failed");
    } else {
        printf("Driver version: %d.%d.%d\n\n",
               (version >> 16) & 0xFF,
               (version >> 8) & 0xFF,
               version & 0xFF);
    }

    /* 测试2: 设置配置 */
    printf("Test 2: Set configuration\n");
    config.mode = 2;
    config.speed = 9600;
    config.flags = 0x01;
    ret = ioctl(fd, MY_IOC_SET_CONFIG, &config);
    if (ret < 0) {
        perror("ioctl SET_CONFIG failed");
    } else {
        printf("Configuration set successfully\n\n");
    }

    /* 测试3: 获取配置 */
    printf("Test 3: Get configuration\n");
    memset(&config, 0, sizeof(config));
    ret = ioctl(fd, MY_IOC_GET_CONFIG, &config);
    if (ret < 0) {
        perror("ioctl GET_CONFIG failed");
    } else {
        printf("Config: mode=%d, speed=%d, flags=0x%x\n\n",
               config.mode, config.speed, config.flags);
    }

    /* 测试4: 获取状态 */
    printf("Test 4: Get device status\n");
    ret = ioctl(fd, MY_IOC_GET_STATUS, &status);
    if (ret < 0) {
        perror("ioctl GET_STATUS failed");
    } else {
        printf("Status: state=%d, errors=%d, uptime=%lu ms\n\n",
               status.state, status.error_count, status.uptime);
    }

    /* 测试5: 设置模式 */
    printf("Test 5: Set mode\n");
    int mode = 3;
    ret = ioctl(fd, MY_IOC_SET_MODE, &mode);
    if (ret < 0) {
        perror("ioctl SET_MODE failed");
    } else {
        printf("Mode set to %d\n\n", mode);
    }

    /* 测试6: 复位设备 */
    printf("Test 6: Reset device\n");
    ret = ioctl(fd, MY_IOC_RESET);
    if (ret < 0) {
        perror("ioctl RESET failed");
    } else {
        printf("Device reset successfully\n\n");
    }

    /* 测试7: 验证复位后的配置 */
    printf("Test 7: Verify config after reset\n");
    ret = ioctl(fd, MY_IOC_GET_CONFIG, &config);
    if (ret < 0) {
        perror("ioctl GET_CONFIG failed");
    } else {
        printf("Config after reset: mode=%d, speed=%d, flags=0x%x\n\n",
               config.mode, config.speed, config.flags);
    }

    /* 测试8: 无效参数测试 */
    printf("Test 8: Invalid mode test\n");
    mode = 10;  /* 无效模式 */
    ret = ioctl(fd, MY_IOC_SET_MODE, &mode);
    if (ret < 0) {
        printf("Expected error: %s\n\n", strerror(errno));
    }

    close(fd);
    printf("=== Test Complete ===\n");
    return 0;
}
```

编译命令：
```bash
gcc -o test_ioctl test_ioctl.c
```

---

## 附录：头文件汇总

```c
#include <linux/ioctl.h>       // ioctl命令定义宏: _IO, _IOR, _IOW, _IOWR
#include <linux/fs.h>          // file_operations结构体
#include <linux/uaccess.h>     // copy_from_user, copy_to_user, access_ok
#include <linux/capability.h>  // capable(), CAP_SYS_ADMIN等
#include <linux/compat.h>      // 32/64位兼容: compat_ptr, ptr_to_compat
#include <linux/cdev.h>        // 字符设备相关
#include <linux/device.h>      // device_create等
```

---

## 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| ioctl返回-ENOTTY | 命令号定义错误或未处理 | 检查魔数和命令号是否一致 |
| ioctl返回-EFAULT | 用户空间地址无效 | 使用access_ok验证地址 |
| ioctl返回-EINVAL | 参数校验失败 | 检查参数范围和合法性 |
| 32位程序调用失败 | 缺少compat_ioctl | 实现compat_ioctl处理 |
| 数据传输错误 | copy_from/to_user使用不当 | 检查数据大小和方向 |
| 权限被拒绝 | 缺少所需能力 | 使用sudo运行或检查capable() |

---

## ioctl最佳实践

1. **使用标准宏定义命令**：始终使用 `_IO`、`_IOR`、`_IOW`、`_IOWR` 定义命令
2. **选择唯一魔数**：查阅内核文档避免魔数冲突
3. **参数校验**：验证所有用户传入的参数
4. **权限控制**：敏感操作使用 `capable()` 检查权限
5. **兼容性处理**：在64位系统上实现 `compat_ioctl`
6. **错误码规范**：使用标准错误码（ENOTTY、EINVAL等）
7. **文档化**：创建公共头文件，清晰定义每个命令的用途
8. **最小权限**：只在必要时使用特权操作
