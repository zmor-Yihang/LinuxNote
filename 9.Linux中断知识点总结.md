# Linux中断知识点总结

## 第一章：中断处理步骤

### 1.1 什么是中断

中断是指CPU在执行程序过程中，遇到外部或内部的紧急事件需要处理时，暂停当前程序的执行，转而去处理这些紧急事件，处理完毕后再返回原程序继续执行的过程。

### 1.2 中断类型

| 中断类型 | 说明 |
|---------|------|
| 硬件中断 | 由外部硬件设备产生，如按键、网卡、串口等 |
| 软件中断（软中断） | 由软件指令触发，如系统调用 |
| 异常 | CPU执行指令时产生的错误，如除零、缺页等 |

### 1.3 中断处理机制：上半部与下半部

Linux内核将中断处理分为两个部分：

| 部分 | 特点 | 适用场景 |
|------|------|---------|
| 上半部（Top Half） | 快速执行、不可被中断、处理紧急任务 | 读取硬件状态、清除中断标志 |
| 下半部（Bottom Half） | 可延迟执行、可被中断、处理耗时任务 | 数据处理、缓冲区操作 |

### 1.4 下半部实现机制

| 机制 | 说明 | 适用场景 |
|------|------|---------|
| 软中断（softirq） | 静态定义、并发执行、效率最高 | 网络、块设备等高性能场景 |
| tasklet | 基于软中断、动态创建、同一tasklet串行执行 | 大多数驱动场景 |
| 工作队列（workqueue） | 进程上下文、可睡眠 | 需要睡眠或耗时较长的操作 |
| 线程化中断 | 中断处理在内核线程中执行 | 实时性要求高的场景 |

### 1.5 中断申请与处理步骤

```
步骤一：获取中断号
    ↓ 使用 gpio_to_irq() 或从设备树获取
步骤二：申请中断
    ↓ 使用 request_irq() 或 devm_request_irq()
步骤三：编写中断处理函数（上半部）
    ↓ 快速处理，返回 IRQ_HANDLED
步骤四：实现下半部（可选）
    ↓ tasklet / 工作队列 / 线程化中断
步骤五：释放中断
    使用 free_irq()（devm_request_irq自动释放）
```

### 1.6 中断处理函数编写原则

1. **快速返回**：上半部处理时间应尽量短
2. **不可睡眠**：中断上下文不能调用可能睡眠的函数
3. **不可调度**：不能使用 `mutex_lock`、`copy_to_user` 等
4. **保存必要状态**：保存硬件状态供下半部使用
5. **正确返回值**：返回 `IRQ_HANDLED` 或 `IRQ_NONE`

### 1.7 中断触发类型

| 触发类型 | 宏定义 | 说明 |
|---------|--------|------|
| 上升沿触发 | IRQF_TRIGGER_RISING | 电平由低变高触发 |
| 下降沿触发 | IRQF_TRIGGER_FALLING | 电平由高变低触发 |
| 双边沿触发 | IRQF_TRIGGER_RISING \| IRQF_TRIGGER_FALLING | 任意边沿触发 |
| 高电平触发 | IRQF_TRIGGER_HIGH | 高电平持续触发 |
| 低电平触发 | IRQF_TRIGGER_LOW | 低电平持续触发 |

---

## 第二章：常用变量、结构体、函数

### 2.1 中断相关头文件

```c
#include <linux/interrupt.h>    /* 中断处理核心头文件 */
#include <linux/irq.h>          /* IRQ相关定义 */
#include <linux/gpio.h>         /* GPIO相关函数 */
#include <linux/of_irq.h>       /* 设备树中断获取 */
#include <linux/workqueue.h>    /* 工作队列 */
```

---

### 2.2 中断申请与释放

#### `request_irq` - 申请中断

```c
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |
| handler | 中断处理函数指针 |
| flags | 中断标志（触发方式、共享等） |
| name | 中断名称，显示在 /proc/interrupts |
| dev | 传递给中断处理函数的私有数据，共享中断时必须唯一 |

**作用**：向内核注册中断处理程序

| 返回值 | 说明 |
|--------|------|
| 0 | 成功 |
| -EINVAL | 中断号无效或处理函数为空 |
| -EBUSY | 中断已被占用且不是共享中断 |

---

#### `devm_request_irq` - 设备管理的中断申请

```c
int devm_request_irq(struct device *dev,
                     unsigned int irq,
                     irq_handler_t handler,
                     unsigned long flags,
                     const char *devname,
                     void *dev_id);
```

| 参数 | 说明 |
|------|------|
| dev | 设备结构体指针 |
| irq | 中断号 |
| handler | 中断处理函数 |
| flags | 中断标志 |
| devname | 中断名称 |
| dev_id | 私有数据 |

**作用**：申请中断，设备移除时自动释放

| 返回值 | 说明 |
|--------|------|
| 0 | 成功 |
| 负值 | 失败，返回错误码 |

---

#### `free_irq` - 释放中断

```c
void free_irq(unsigned int irq, void *dev_id);
```

| 参数 | 说明 |
|------|------|
| irq | 要释放的中断号 |
| dev_id | 申请时传入的私有数据，必须与申请时一致 |

**作用**：释放之前申请的中断

---

#### `request_threaded_irq` - 申请线程化中断

```c
int request_threaded_irq(unsigned int irq,
                         irq_handler_t handler,
                         irq_handler_t thread_fn,
                         unsigned long irqflags,
                         const char *devname,
                         void *dev_id);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |
| handler | 上半部处理函数，可为NULL |
| thread_fn | 线程化处理函数（下半部） |
| irqflags | 中断标志 |
| devname | 中断名称 |
| dev_id | 私有数据 |

**作用**：申请线程化中断，handler返回IRQ_WAKE_THREAD时唤醒线程执行thread_fn

| 返回值 | 说明 |
|--------|------|
| 0 | 成功 |
| 负值 | 失败 |

---

### 2.3 中断号获取

#### `gpio_to_irq` - GPIO转中断号

```c
int gpio_to_irq(unsigned int gpio);
```

| 参数 | 说明 |
|------|------|
| gpio | GPIO编号 |

**作用**：将GPIO编号转换为对应的中断号

| 返回值 | 说明 |
|--------|------|
| ≥0 | 中断号 |
| 负值 | 转换失败 |

---

#### `irq_of_parse_and_map` - 从设备树获取中断号

```c
unsigned int irq_of_parse_and_map(struct device_node *np, int index);
```

| 参数 | 说明 |
|------|------|
| np | 设备节点指针 |
| index | interrupts属性中的索引 |

**作用**：解析设备树中的interrupts属性并映射为中断号

| 返回值 | 说明 |
|--------|------|
| >0 | 中断号 |
| 0 | 失败 |

---

#### `platform_get_irq` - 从平台设备获取中断号

```c
int platform_get_irq(struct platform_device *dev, unsigned int num);
```

| 参数 | 说明 |
|------|------|
| dev | 平台设备指针 |
| num | 中断索引 |

**作用**：从平台设备资源中获取中断号

| 返回值 | 说明 |
|--------|------|
| ≥0 | 中断号 |
| 负值 | 失败 |

---

### 2.4 中断控制

#### `enable_irq` - 使能中断

```c
void enable_irq(unsigned int irq);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |

**作用**：使能指定中断，与disable_irq配对使用

---

#### `disable_irq` - 禁止中断（等待中断处理完成）

```c
void disable_irq(unsigned int irq);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |

**作用**：禁止指定中断，会等待正在执行的中断处理程序完成

---

#### `disable_irq_nosync` - 禁止中断（立即返回）

```c
void disable_irq_nosync(unsigned int irq);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |

**作用**：禁止指定中断，立即返回，不等待中断处理程序完成

---

#### `local_irq_disable` - 禁止本地CPU中断

```c
void local_irq_disable(void);
```

**作用**：禁止当前CPU的所有中断

---

#### `local_irq_enable` - 使能本地CPU中断

```c
void local_irq_enable(void);
```

**作用**：使能当前CPU的所有中断

---

#### `local_irq_save` - 保存并禁止本地中断

```c
local_irq_save(unsigned long flags);
```

| 参数 | 说明 |
|------|------|
| flags | 用于保存中断状态的变量 |

**作用**：保存当前中断状态并禁止中断

---

#### `local_irq_restore` - 恢复本地中断状态

```c
local_irq_restore(unsigned long flags);
```

| 参数 | 说明 |
|------|------|
| flags | 之前保存的中断状态 |

**作用**：恢复之前保存的中断状态

---

### 2.5 Tasklet（下半部机制）

#### `struct tasklet_struct` - Tasklet结构体

```c
struct tasklet_struct {
    struct tasklet_struct *next;    /* 链表指针 */
    unsigned long state;            /* 状态 */
    atomic_t count;                 /* 引用计数 */
    void (*func)(unsigned long);    /* 处理函数 */
    unsigned long data;             /* 传递给func的参数 */
};
```

---

#### `tasklet_init` - 动态初始化Tasklet

```c
void tasklet_init(struct tasklet_struct *t,
                  void (*func)(unsigned long),
                  unsigned long data);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |
| func | tasklet处理函数 |
| data | 传递给处理函数的参数 |

**作用**：动态初始化一个tasklet

---

#### `DECLARE_TASKLET` - 静态定义Tasklet

```c
DECLARE_TASKLET(name, func, data);
```

| 参数 | 说明 |
|------|------|
| name | tasklet变量名 |
| func | 处理函数 |
| data | 传递给处理函数的参数 |

**作用**：静态定义并初始化一个tasklet

---

#### `tasklet_disable` - 禁止Tasklet

```c
void tasklet_disable(struct tasklet_struct *t);
```

| 参数 | 说明              |
| ---- | ----------------- |
| t    | tasklet结构体指针 |

**作用**：禁止tasklet执行，等待正在执行的完成

---

#### `tasklet_enable` - 使能Tasklet

```c
void tasklet_enable(struct tasklet_struct *t);
```

| 参数 | 说明              |
| ---- | ----------------- |
| t    | tasklet结构体指针 |

**作用**：使能被禁止的tasklet

------

#### `tasklet_schedule` - 调度Tasklet

```c
void tasklet_schedule(struct tasklet_struct *t);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |

**作用**：将tasklet加入调度队列，等待执行

---

#### `tasklet_hi_schedule` - 高优先级调度Tasklet

```c
void tasklet_hi_schedule(struct tasklet_struct *t);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |

**作用**：以高优先级调度tasklet

---

#### `tasklet_kill` - 终止Tasklet

```c
void tasklet_kill(struct tasklet_struct *t);
```

| 参数 | 说明              |
| ---- | ----------------- |
| t    | tasklet结构体指针 |

**作用**：等待tasklet执行完成并从调度队列移除

------

### 2.6 工作队列（下半部机制）

#### 2.6.1 工作队列相关结构体

##### `struct work_struct` - 工作结构体

```c
struct work_struct {
    atomic_long_t data;         /* 工作状态和数据 */
    struct list_head entry;     /* 链表节点，用于加入工作队列 */
    work_func_t func;           /* 工作处理函数 */
};
```

**作用**：描述一个工作项，用于在进程上下文中执行延迟任务

---

##### `struct delayed_work` - 延迟工作结构体

```c
struct delayed_work {
    struct work_struct work;    /* 内嵌的工作结构体 */
    struct timer_list timer;    /* 定时器，用于延迟调度 */
    struct workqueue_struct *wq; /* 关联的工作队列 */
    int cpu;                    /* 目标CPU */
};
```

**作用**：用于实现延迟执行的工作队列任务，内部通过定时器在指定延迟后将工作加入队列执行

---

##### `struct workqueue_struct` - 工作队列结构体

```c
struct workqueue_struct {
    struct list_head pwqs;                      /* 指向所有 pool_workqueue */
    struct list_head list;                      /* 全局工作队列链表节点 */
    const char *name;                           /* 工作队列名称 */
    unsigned int flags;                         /* 创建标志（WQ_*） */
    int saved_max_active;                       /* 最大并发工作数 */
    struct pool_workqueue __percpu *cpu_pools;  /* 每CPU的工作队列池 */
    struct pool_workqueue *unbound_pool;        /* 非绑定工作队列池 */
};
```

**作用**：管理工作项的队列，可以是系统默认队列或自定义队列

---

##### `work_func_t` - 工作处理函数类型

```c
typedef void (*work_func_t)(struct work_struct *work);
```

**作用**：定义工作处理函数的类型，在进程上下文中执行，可以睡眠

---

#### 2.6.2 工作队列初始化API

##### `INIT_WORK` - 动态初始化工作

```c
INIT_WORK(struct work_struct *work, work_func_t func);
```

| 参数 | 说明 |
|------|------|
| work | work_struct指针 |
| func | 工作处理函数 |

**作用**：初始化一个工作结构体

---

#### `DECLARE_WORK` - 静态定义工作

```c
DECLARE_WORK(name, func);
```

| 参数 | 说明 |
|------|------|
| name | 工作变量名 |
| func | 处理函数 |

**作用**：静态定义并初始化一个work_struct

---

#### `INIT_DELAYED_WORK` - 初始化延迟工作

```c
INIT_DELAYED_WORK(struct delayed_work *work, work_func_t func);
```

| 参数 | 说明 |
|------|------|
| work | delayed_work结构体指针 |
| func | 工作处理函数 |

**作用**：初始化一个延迟工作结构体

---

#### `DECLARE_DELAYED_WORK` - 静态定义延迟工作

```c
DECLARE_DELAYED_WORK(name, func);
```

| 参数 | 说明 |
|------|------|
| name | 延迟工作变量名 |
| func | 处理函数 |

**作用**：静态定义并初始化一个delayed_work结构体

---

#### 2.6.3 工作队列创建与销毁API

##### `create_workqueue` - 创建工作队列（旧接口）

```c
struct workqueue_struct *create_workqueue(const char *name);
```

| 参数 | 说明 |
|------|------|
| name | 工作队列名称 |

**作用**：创建一个工作队列，每个CPU一个工作线程

| 返回值 | 说明 |
|--------|------|
| 非NULL | 工作队列指针 |
| NULL | 创建失败 |

---

##### `create_singlethread_workqueue` - 创建单线程工作队列

```c
struct workqueue_struct *create_singlethread_workqueue(const char *name);
```

| 参数 | 说明 |
|------|------|
| name | 工作队列名称 |

**作用**：创建只有一个工作线程的工作队列

| 返回值 | 说明 |
|--------|------|
| 非NULL | 工作队列指针 |
| NULL | 创建失败 |

---

##### `alloc_workqueue` - 分配工作队列（推荐）

```c
struct workqueue_struct *alloc_workqueue(const char *fmt,
                                         unsigned int flags,
                                         int max_active, ...);
```

| 参数 | 说明 |
|------|------|
| fmt | 名称格式字符串 |
| flags | 工作队列标志 |
| max_active | 最大并发工作数，0表示默认值 |

**作用**：创建具有指定属性的工作队列

**常用标志：**
- `WQ_UNBOUND` - 不绑定到特定CPU
- `WQ_FREEZABLE` - 系统休眠时可冻结
- `WQ_MEM_RECLAIM` - 用于内存回收路径
- `WQ_HIGHPRI` - 高优先级工作队列
- `WQ_CPU_INTENSIVE` - CPU密集型任务

| 返回值 | 说明 |
|--------|------|
| 非NULL | 工作队列指针 |
| NULL | 创建失败 |

**示例：**
```c
/* 创建非绑定、可冻结的工作队列 */
wq = alloc_workqueue("my_wq", WQ_UNBOUND | WQ_FREEZABLE, 0);
```

---

##### `alloc_ordered_workqueue` - 创建有序工作队列

```c
#define alloc_ordered_workqueue(fmt, flags, args...)  \
    alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED | (flags), 1, ##args)
```

| 参数 | 说明 |
|------|------|
| fmt | 名称格式字符串 |
| flags | 附加标志 |

**作用**：创建按提交顺序执行的工作队列（串行执行）

---

##### `destroy_workqueue` - 销毁工作队列

```c
void destroy_workqueue(struct workqueue_struct *wq);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |

**作用**：销毁工作队列并等待所有工作完成，释放资源

---

#### 2.6.4 工作调度API（系统队列）

##### `schedule_work` - 调度工作到系统工作队列

```c
bool schedule_work(struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| work | work_struct指针 |

**作用**：将工作加入系统默认工作队列

| 返回值 | 说明 |
|--------|------|
| true | 成功加入队列 |
| false | 工作已在队列中 |

---

#### `schedule_delayed_work` - 延迟调度工作

```c
bool schedule_delayed_work(struct delayed_work *dwork, 
                          unsigned long delay);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |
| delay | 延迟时间（jiffies） |

**作用**：将延迟工作加入系统默认工作队列，在delay jiffies后执行

| 返回值 | 说明 |
|--------|------|
| true | 成功加入队列 |
| false | 工作已在队列中 |

---

#### `queue_delayed_work` - 将延迟工作加入指定队列

```c
bool queue_delayed_work(struct workqueue_struct *wq,
                       struct delayed_work *dwork,
                       unsigned long delay);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |
| dwork | delayed_work指针 |
| delay | 延迟时间（jiffies） |

**作用**：将延迟工作加入指定的工作队列，在delay后执行

| 返回值 | 说明 |
|--------|------|
| true | 成功加入队列 |
| false | 工作已在队列中 |

---

#### `mod_delayed_work` - 修改延迟工作的延迟时间

```c
bool mod_delayed_work(struct workqueue_struct *wq,
                     struct delayed_work *dwork,
                     unsigned long delay);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |
| dwork | delayed_work指针 |
| delay | 新的延迟时间（jiffies） |

**作用**：修改已调度的延迟工作的延迟时间，如果工作未调度则调度它

| 返回值 | 说明 |
|--------|------|
| true | 工作已在队列中，延迟时间已修改 |
| false | 工作未在队列中，已重新调度 |

---

#### `cancel_delayed_work` - 取消延迟工作

```c
bool cancel_delayed_work(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：取消已调度的延迟工作（非阻塞）

| 返回值 | 说明 |
|--------|------|
| true | 成功取消 |
| false | 工作未在队列中或正在执行 |

---

#### `cancel_delayed_work_sync` - 同步取消延迟工作

```c
bool cancel_delayed_work_sync(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：取消延迟工作，如果工作正在执行则等待完成

| 返回值 | 说明 |
|--------|------|
| true | 工作被取消或已完成 |
| false | 工作未在队列中 |

> ⚠️ **注意**：该函数会睡眠，只能在进程上下文调用

---

#### `flush_delayed_work` - 等待延迟工作完成

```c
bool flush_delayed_work(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：等待延迟工作执行完成，如果尚未执行则立即执行

| 返回值 | 说明 |
|--------|------|
| true | 工作已执行完成 |
| false | 工作未被调度 |

---

#### `delayed_work_pending` - 检查延迟工作是否挂起

```c
bool delayed_work_pending(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：检查延迟工作是否在等待执行

| 返回值 | 说明 |
|--------|------|
| true | 工作在队列中等待 |
| false | 工作未被调度 |

---

#### 2.6.5 工作调度API（自定义队列）

##### `queue_work` - 将工作加入指定队列

```c
bool queue_work(struct workqueue_struct *wq, struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |
| work | work_struct指针 |

**作用**：将工作加入指定的工作队列

| 返回值 | 说明 |
|--------|------|
| true | 成功加入队列 |
| false | 工作已在队列中 |

---

##### `queue_work_on` - 将工作加入指定CPU的队列

```c
bool queue_work_on(int cpu, struct workqueue_struct *wq, 
                   struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| cpu | 目标CPU编号 |
| wq | 工作队列指针 |
| work | work_struct指针 |

**作用**：将工作提交到指定CPU的工作队列

| 返回值 | 说明 |
|--------|------|
| true | 成功加入队列 |
| false | 工作已在队列中 |

---

##### `queue_delayed_work_on` - 延迟加入指定CPU的队列

```c
bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
                          struct delayed_work *dwork,
                          unsigned long delay);
```

| 参数 | 说明 |
|------|------|
| cpu | 目标CPU编号 |
| wq | 工作队列指针 |
| dwork | delayed_work指针 |
| delay | 延迟时间（jiffies） |

**作用**：延迟将工作提交到指定CPU的工作队列

---

#### 2.6.6 工作取消API

##### `cancel_work` - 取消工作（非阻塞）

```c
bool cancel_work(struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| work | work_struct指针 |

**作用**：尝试取消工作，不等待执行完成

| 返回值 | 说明 |
|--------|------|
| true | 成功取消 |
| false | 工作未在队列或正在执行 |

---

##### `cancel_work_sync` - 同步取消工作

```c
bool cancel_work_sync(struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| work | work_struct指针 |

**作用**：取消工作，如正在执行则等待完成

| 返回值 | 说明 |
|--------|------|
| true | 工作被取消 |
| false | 工作未在队列中 |

> ⚠️ **注意**：会睡眠，只能在进程上下文调用

---

##### `cancel_delayed_work` - 取消延迟工作（非阻塞）

```c
bool cancel_delayed_work(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：取消已调度的延迟工作，立即返回

| 返回值 | 说明 |
|--------|------|
| true | 成功取消 |
| false | 工作未在队列或正在执行 |

---

##### `cancel_delayed_work_sync` - 同步取消延迟工作

```c
bool cancel_delayed_work_sync(struct delayed_work *dwork);
```

| 参数 | 说明 |
|------|------|
| dwork | delayed_work指针 |

**作用**：取消延迟工作，等待正在执行的完成

| 返回值 | 说明 |
|--------|------|
| true | 工作被取消或已完成 |
| false | 工作未在队列中 |

> ⚠️ **注意**：会睡眠，只能在进程上下文调用

---

#### 2.6.7 工作刷新与同步API

##### `flush_work` - 等待指定工作项完成

```c
bool flush_work(struct work_struct *work);
```

| 参数 | 说明               |
| ---- | ------------------ |
| work | `work_struct` 指针 |

**作用**：阻塞当前上下文，直到指定的工作项**不再处于排队或执行状态**，确保其已完全执行完毕（若已被调度）。常用于模块卸载或资源释放前的安全同步。

| 返回值  | 说明                                                |
| ------- | --------------------------------------------------- |
| `true`  | 指定的工作项曾处于 pending 或正在执行状态，现已完成 |
| `false` | 工作项当前未被调度（可能已执行完毕或从未被提交）    |

> ⚠️ **注意**：该函数会睡眠，**只能在进程上下文调用**，不可在中断上下文或持有自旋锁时使用。

------

#### `alloc_workqueue` - 分配工作队列

```c
struct workqueue_struct *alloc_workqueue(const char *fmt,
                                         unsigned int flags,
                                         int max_active, ...);
```

| 参数 | 说明 |
|------|------|
| fmt | 名称格式 |
| flags | 标志（WQ_UNBOUND、WQ_HIGHPRI等） |
| max_active | 最大活动工作数 |

**作用**：创建工作队列，可指定更多选项

---

#### `queue_work` - 将工作加入指定队列

```c
bool queue_work(struct workqueue_struct *wq, struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |
| work | work_struct指针 |

**作用**：将工作加入指定的工作队列，相当于告诉CPU唤醒处理软中断的线程（该线程可以是自己创建的，也可以是CPU默认的线程）

---

#### `flush_workqueue` - 刷新工作队列

```c
void flush_workqueue(struct workqueue_struct *wq);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |

**作用**：等待工作队列中所有工作完成

---

#### `destroy_workqueue` - 销毁工作队列

```c
void destroy_workqueue(struct workqueue_struct *wq);
```

| 参数 | 说明 |
|------|------|
| wq | 工作队列指针 |

**作用**：销毁工作队列，释放资源

---

#### `cancel_work_sync` - 取消并等待工作完成

```c
bool cancel_work_sync(struct work_struct *work);
```

| 参数 | 说明 |
|------|------|
| work | work_struct指针 |

**作用**：取消工作，如正在执行则等待完成

---

### 2.7 软中断与Tasklet高级API

#### 2.7.1 软中断相关

##### `raise_softirq` - 触发软中断

```c
void raise_softirq(unsigned int nr);
```

| 参数 | 说明 |
|------|------|
| nr | 软中断编号 |

**作用**：触发指定的软中断

---

##### `open_softirq` - 注册软中断处理函数

```c
void open_softirq(int nr, void (*action)(struct softirq_action *));
```

| 参数 | 说明 |
|------|------|
| nr | 软中断编号 |
| action | 软中断处理函数 |

**作用**：注册软中断处理函数（通常由内核子系统使用）

---

##### 软中断类型枚举

```c
enum {
    HI_SOFTIRQ = 0,         /* 高优先级tasklet */
    TIMER_SOFTIRQ,          /* 定时器软中断 */
    NET_TX_SOFTIRQ,         /* 网络发送 */
    NET_RX_SOFTIRQ,         /* 网络接收 */
    BLOCK_SOFTIRQ,          /* 块设备 */
    IRQ_POLL_SOFTIRQ,       /* IO轮询 */
    TASKLET_SOFTIRQ,        /* 普通tasklet */
    SCHED_SOFTIRQ,          /* 调度器 */
    HRTIMER_SOFTIRQ,        /* 高精度定时器 */
    RCU_SOFTIRQ,            /* RCU */
};
```

---

#### 2.7.2 Tasklet高级API

##### `tasklet_trylock` - 尝试锁定Tasklet

```c
int tasklet_trylock(struct tasklet_struct *t);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |

**作用**：尝试锁定tasklet，如果已被锁定则返回失败

| 返回值 | 说明 |
|--------|------|
| 1 | 成功锁定 |
| 0 | 已被锁定 |

---

##### `tasklet_unlock` - 解锁Tasklet

```c
void tasklet_unlock(struct tasklet_struct *t);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |

**作用**：解锁之前锁定的tasklet

---

##### `tasklet_unlock_wait` - 等待Tasklet解锁

```c
void tasklet_unlock_wait(struct tasklet_struct *t);
```

| 参数 | 说明 |
|------|------|
| t | tasklet结构体指针 |

**作用**：等待tasklet被解锁

---

### 2.8 中断处理函数类型与返回值

#### `irq_handler_t` - 中断处理函数类型

```c
typedef irqreturn_t (*irq_handler_t)(int irq, void *dev_id);
```

**函数原型：**
```c
irqreturn_t handler(int irq, void *dev_id)
{
    /* 中断处理代码 */
    return IRQ_HANDLED;
}
```

**参数说明：**
- `irq` - 中断号
- `dev_id` - 申请中断时传入的私有数据指针

---

#### `irqreturn_t` - 中断处理函数返回值类型

```c
enum irqreturn {
    IRQ_NONE        = (0 << 0),  /* 中断不是本设备产生 */
    IRQ_HANDLED     = (1 << 0),  /* 中断已正常处理 */
    IRQ_WAKE_THREAD = (1 << 1),  /* 唤醒线程化处理 */
};
typedef enum irqreturn irqreturn_t;
```

**返回值说明：**

| 返回值 | 说明 | 使用场景 |
|--------|------|---------|
| IRQ_NONE | 中断不是本设备产生的 | 共享中断中，判断不是自己的中断 |
| IRQ_HANDLED | 中断已正常处理 | 普通中断处理完成 |
| IRQ_WAKE_THREAD | 唤醒线程化处理函数 | 线程化中断的上半部 |

---

### 2.9 中断上下文判断API

#### `in_interrupt` - 判断是否在中断上下文

```c
bool in_interrupt(void);
```

**作用**：判断当前代码是否在中断上下文中执行

| 返回值 | 说明 |
|--------|------|
| true | 在中断上下文（硬中断或软中断） |
| false | 在进程上下文 |

---

#### `in_irq` - 判断是否在硬中断上下文

```c
bool in_irq(void);
```

**作用**：判断当前是否在硬件中断处理中

| 返回值 | 说明 |
|--------|------|
| true | 在硬中断上下文 |
| false | 不在硬中断上下文 |

---

#### `in_softirq` - 判断是否在软中断上下文

```c
bool in_softirq(void);
```

**作用**：判断当前是否在软中断处理中

| 返回值 | 说明 |
|--------|------|
| true | 在软中断上下文 |
| false | 不在软中断上下文 |

---

#### `in_serving_softirq` - 判断是否正在处理软中断

```c
bool in_serving_softirq(void);
```

**作用**：判断当前是否正在处理软中断（区别于软中断被禁止）

---

#### `in_task` - 判断是否在进程上下文

```c
bool in_task(void);
```

**作用**：判断当前是否在进程上下文

| 返回值 | 说明 |
|--------|------|
| true | 在进程上下文 |
| false | 在中断上下文 |

---

### 2.10 时间转换宏与jiffies

#### 2.10.1 jiffies相关

##### `jiffies` - 系统运行的节拍数

```c
extern unsigned long volatile jiffies;
```

**作用**：记录系统启动以来的时钟节拍数

---

##### `HZ` - 系统时钟频率

```c
#define HZ 100  /* 或 250, 300, 1000，取决于内核配置 */
```

**作用**：每秒的时钟节拍数，1秒 = HZ个jiffies

---

#### 2.10.2 时间转换API

在使用延迟工作和定时器时，需要在不同时间单位间转换：

| 宏/函数 | 说明 | 示例 |
|---------|------|------|
| `msecs_to_jiffies(ms)` | 毫秒转jiffies | `msecs_to_jiffies(100)` |
| `usecs_to_jiffies(us)` | 微秒转jiffies | `usecs_to_jiffies(5000)` |
| `nsecs_to_jiffies(ns)` | 纳秒转jiffies | `nsecs_to_jiffies(1000000)` |
| `jiffies_to_msecs(j)` | jiffies转毫秒 | `jiffies_to_msecs(HZ)` |
| `jiffies_to_usecs(j)` | jiffies转微秒 | `jiffies_to_usecs(10)` |
| `jiffies_to_nsecs(j)` | jiffies转纳秒 | `jiffies_to_nsecs(1)` |
| `timespec_to_jiffies(ts)` | timespec转jiffies | - |
| `jiffies_to_timespec(j, ts)` | jiffies转timespec | - |
| `timeval_to_jiffies(tv)` | timeval转jiffies | - |
| `jiffies_to_timeval(j, tv)` | jiffies转timeval | - |

---

#### 2.10.3 时间比较API

##### `time_after` - 时间是否在之后

```c
#define time_after(a, b) ((long)((b) - (a)) < 0)
```

**作用**：判断时间a是否在时间b之后（处理溢出）

---

##### `time_before` - 时间是否在之前

```c
#define time_before(a, b) time_after(b, a)
```

**作用**：判断时间a是否在时间b之前

---

##### `time_after_eq` - 时间是否在之后或相等

```c
#define time_after_eq(a, b) ((long)((a) - (b)) >= 0)
```

---

##### `time_before_eq` - 时间是否在之前或相等

```c
#define time_before_eq(a, b) time_after_eq(b, a)
```

---

#### 2.10.4 时间转换使用示例

```c
/* 延迟100毫秒后执行 */
schedule_delayed_work(&dwork, msecs_to_jiffies(100));

/* 延迟1秒后执行 */
schedule_delayed_work(&dwork, HZ);

/* 延迟500微秒后执行 */
schedule_delayed_work(&dwork, usecs_to_jiffies(500));

/* 延迟10纳秒后执行 */
schedule_delayed_work(&dwork, nsecs_to_jiffies(10000000));

/* 检查超时 */
unsigned long timeout = jiffies + msecs_to_jiffies(1000);
if (time_after(jiffies, timeout)) {
    pr_err("Operation timeout!\n");
}
```

---

### 2.11 中断标志详解

#### 2.11.1 中断触发类型标志

| 标志 | 值 | 说明 |
|------|-------|------|
| `IRQF_TRIGGER_NONE` | 0x00000000 | 无触发类型（使用默认） |
| `IRQF_TRIGGER_RISING` | 0x00000001 | 上升沿触发 |
| `IRQF_TRIGGER_FALLING` | 0x00000002 | 下降沿触发 |
| `IRQF_TRIGGER_HIGH` | 0x00000004 | 高电平触发 |
| `IRQF_TRIGGER_LOW` | 0x00000008 | 低电平触发 |
| `IRQF_TRIGGER_MASK` | 0x0000000F | 触发类型掩码 |

---

#### 2.11.2 中断行为控制标志

| 标志 | 说明 | 使用场景 |
|------|------|---------|
| `IRQF_SHARED` | 共享中断，多个设备可使用同一中断线 | 多设备共享中断号 |
| `IRQF_PROBE_SHARED` | 探测时允许共享 | 中断探测阶段 |
| `IRQF_ONESHOT` | 单次触发，处理完前不会再次触发 | 线程化中断，防止中断风暴 |
| `IRQF_NO_SUSPEND` | 系统休眠时不禁止该中断 | 唤醒源中断 |
| `IRQF_FORCE_RESUME` | 系统恢复时强制恢复中断 | 特殊唤醒场景 |
| `IRQF_NO_THREAD` | 强制在硬中断上下文执行 | 实时性要求极高 |
| `IRQF_EARLY_RESUME` | 系统恢复早期就恢复中断 | 关键设备中断 |
| `IRQF_COND_SUSPEND` | 条件性休眠时禁用 | - |

---

#### 2.11.3 中断定时器标志

| 标志 | 说明 |
|------|------|
| `IRQF_TIMER` | 中断用于定时器 |
| `IRQF_PERCPU` | 每CPU中断 |
| `IRQF_NOBALANCING` | 不参与中断均衡 |

---

#### 2.11.4 常用标志组合示例

```c
/* 上升沿和下降沿都触发 */
IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING

/* 共享中断，下降沿触发 */
IRQF_SHARED | IRQF_TRIGGER_FALLING

/* 线程化中断，单次触发，下降沿 */
IRQF_ONESHOT | IRQF_TRIGGER_FALLING

/* 系统休眠时不禁止，用作唤醒源 */
IRQF_NO_SUSPEND | IRQF_TRIGGER_FALLING
```

---

### 2.12 中断统计与调试API

#### `irq_stat` - 中断统计结构

```c
DECLARE_PER_CPU(irq_cpustat_t, irq_stat);
```

**作用**：每CPU的中断统计信息

---

#### `kstat_irqs` - 获取中断触发次数

```c
unsigned int kstat_irqs(unsigned int irq);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |

**作用**：获取指定中断的触发总次数

---

#### `kstat_irqs_cpu` - 获取特定CPU的中断次数

```c
unsigned int kstat_irqs_cpu(unsigned int irq, int cpu);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |
| cpu | CPU编号 |

**作用**：获取指定中断在特定CPU上的触发次数

---

#### `synchronize_irq` - 同步等待中断处理完成

```c
void synchronize_irq(unsigned int irq);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |

**作用**：等待指定中断的所有处理程序完成

---

#### `irq_set_affinity` - 设置中断亲和性

```c
int irq_set_affinity(unsigned int irq, const struct cpumask *cpumask);
```

| 参数 | 说明 |
|------|------|
| irq | 中断号 |
| cpumask | CPU掩码 |

**作用**：设置中断到指定CPU的亲和性

---

### 2.13 devm_*资源管理API

#### `devm_request_irq` - 设备管理的中断申请（已介绍）

#### `devm_request_threaded_irq` - 设备管理的线程化中断

```c
int devm_request_threaded_irq(struct device *dev, unsigned int irq,
                              irq_handler_t handler,
                              irq_handler_t thread_fn,
                              unsigned long irqflags,
                              const char *devname,
                              void *dev_id);
```

**作用**：申请线程化中断，设备移除时自动释放

---

#### `devm_free_irq` - 手动释放devm中断

```c
void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
```

| 参数 | 说明 |
|------|------|
| dev | 设备结构体指针 |
| irq | 中断号 |
| dev_id | 私有数据 |

**作用**：手动释放由devm_request_irq申请的中断

---

## 第三章：示例代码

### 3.1 基础中断示例 - GPIO按键中断

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/uaccess.h>

#define DEVICE_NAME     "irq_key"
#define GPIO_KEY        100     /* 根据实际硬件修改 */

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;
static int irq_num;
static volatile int key_value = 0;

/* 中断处理函数（上半部） */
static irqreturn_t key_irq_handler(int irq, void *dev_id)
{
    /* 读取GPIO电平判断按键状态 */
    key_value = gpio_get_value(GPIO_KEY);
    pr_info("Key interrupt! GPIO value: %d\n", key_value);
    
    return IRQ_HANDLED;
}

static ssize_t key_read(struct file *filp, char __user *buf,
                        size_t count, loff_t *f_pos)
{
    int ret;
    
    ret = copy_to_user(buf, (void *)&key_value, sizeof(key_value));
    if (ret)
        return -EFAULT;
    
    return sizeof(key_value);
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read  = key_read,
};

static int __init irq_key_init(void)
{
    int ret;
    
    /* 1. 申请GPIO */
    ret = gpio_request(GPIO_KEY, "key_gpio");
    if (ret) {
        pr_err("Failed to request GPIO\n");
        return ret;
    }
    
    /* 2. 设置GPIO为输入模式 */
    gpio_direction_input(GPIO_KEY);
    
    /* 3. 获取中断号 */
    irq_num = gpio_to_irq(GPIO_KEY);
    if (irq_num < 0) {
        pr_err("Failed to get IRQ number\n");
        ret = irq_num;
        goto fail_irq;
    }
    pr_info("IRQ number: %d\n", irq_num);
    
    /* 4. 申请中断 */
    ret = request_irq(irq_num, 
                      key_irq_handler,
                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                      "key_irq",
                      NULL);
    if (ret) {
        pr_err("Failed to request IRQ\n");
        goto fail_irq;
    }
    
    /* 5. 注册字符设备 */
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_chrdev;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("IRQ key driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_chrdev:
    free_irq(irq_num, NULL);
fail_irq:
    gpio_free(GPIO_KEY);
    return ret;
}

static void __exit irq_key_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    free_irq(irq_num, NULL);
    gpio_free(GPIO_KEY);
    pr_info("IRQ key driver unloaded\n");
}

module_init(irq_key_init);
module_exit(irq_key_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("GPIO Key Interrupt Driver");
```

---

### 3.2 Tasklet下半部示例

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>

#define GPIO_KEY    100

static int irq_num;
static int key_status;

/* 定义Tasklet */
static struct tasklet_struct my_tasklet;

/* Tasklet处理函数（下半部） */
static void tasklet_handler(unsigned long data)
{
    /* 在这里处理耗时操作 */
    pr_info("Tasklet: Key status = %d\n", key_status);
    
    /* 模拟耗时操作 */
    /* 注意：tasklet中仍不能睡眠 */
}

/* 中断处理函数（上半部） */
static irqreturn_t key_irq_handler(int irq, void *dev_id)
{
    /* 快速读取硬件状态 */
    key_status = gpio_get_value(GPIO_KEY);
    
    /* 调度Tasklet执行下半部 */
    tasklet_schedule(&my_tasklet);
    
    return IRQ_HANDLED;
}

static int __init tasklet_demo_init(void)
{
    int ret;
    
    /* 申请GPIO */
    ret = gpio_request(GPIO_KEY, "key_gpio");
    if (ret)
        return ret;
    
    gpio_direction_input(GPIO_KEY);
    
    /* 获取中断号 */
    irq_num = gpio_to_irq(GPIO_KEY);
    if (irq_num < 0) {
        gpio_free(GPIO_KEY);
        return irq_num;
    }
    
    /* 初始化Tasklet */
    tasklet_init(&my_tasklet, tasklet_handler, 0);
    
    /* 申请中断 */
    ret = request_irq(irq_num,
                      key_irq_handler,
                      IRQF_TRIGGER_FALLING,
                      "tasklet_key",
                      NULL);
    if (ret) {
        tasklet_kill(&my_tasklet);
        gpio_free(GPIO_KEY);
        return ret;
    }
    
    pr_info("Tasklet demo driver loaded\n");
    return 0;
}

static void __exit tasklet_demo_exit(void)
{
    free_irq(irq_num, NULL);
    tasklet_kill(&my_tasklet);
    gpio_free(GPIO_KEY);
    pr_info("Tasklet demo driver unloaded\n");
}

module_init(tasklet_demo_init);
module_exit(tasklet_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Tasklet Demo Driver");
```

---

### 3.3 工作队列下半部示例

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/delay.h>

#define GPIO_KEY    100

static int irq_num;

/* 自定义设备数据结构 */
struct key_dev {
    int gpio;
    int irq;
    int key_value;
    struct work_struct work;        /* 工作结构体 */
    struct delayed_work dwork;      /* 延迟工作结构体 */
};

static struct key_dev *key_device;

/* 工作处理函数（下半部，进程上下文，可以睡眠） */
static void work_handler(struct work_struct *work)
{
    struct key_dev *dev = container_of(work, struct key_dev, work);
    
    pr_info("Work queue: Processing key event\n");
    
    /* 可以进行睡眠操作 */
    msleep(10);  /* 消抖延时 */
    
    /* 读取按键值 */
    dev->key_value = gpio_get_value(dev->gpio);
    pr_info("Work queue: Key value = %d\n", dev->key_value);
}

/* 延迟工作处理函数 */
static void delayed_work_handler(struct work_struct *work)
{
    struct delayed_work *dwork = to_delayed_work(work);
    struct key_dev *dev = container_of(dwork, struct key_dev, dwork);
    
    pr_info("Delayed work: Key value = %d\n", dev->key_value);
}

/* 中断处理函数（上半部） */
static irqreturn_t key_irq_handler(int irq, void *dev_id)
{
    struct key_dev *dev = (struct key_dev *)dev_id;
    
    /* 调度工作队列 */
    schedule_work(&dev->work);
    
    /* 或者调度延迟工作（100ms后执行） */
    /* schedule_delayed_work(&dev->dwork, msecs_to_jiffies(100)); */
    
    return IRQ_HANDLED;
}

static int __init workqueue_demo_init(void)
{
    int ret;
    
    /* 分配设备结构体 */
    key_device = kzalloc(sizeof(*key_device), GFP_KERNEL);
    if (!key_device)
        return -ENOMEM;
    
    key_device->gpio = GPIO_KEY;
    
    /* 申请GPIO */
    ret = gpio_request(key_device->gpio, "key_gpio");
    if (ret)
        goto fail_gpio;
    
    gpio_direction_input(key_device->gpio);
    
    /* 获取中断号 */
    key_device->irq = gpio_to_irq(key_device->gpio);
    if (key_device->irq < 0) {
        ret = key_device->irq;
        goto fail_irq_num;
    }
    
    /* 初始化工作 */
    INIT_WORK(&key_device->work, work_handler);
    INIT_DELAYED_WORK(&key_device->dwork, delayed_work_handler);
    
    /* 申请中断 */
    ret = request_irq(key_device->irq,
                      key_irq_handler,
                      IRQF_TRIGGER_FALLING,
                      "workqueue_key",
                      key_device);    /* 传递设备数据 */
    if (ret)
        goto fail_irq;
    
    pr_info("Workqueue demo driver loaded\n");
    return 0;

fail_irq:
    cancel_work_sync(&key_device->work);
    cancel_delayed_work_sync(&key_device->dwork);
fail_irq_num:
    gpio_free(key_device->gpio);
fail_gpio:
    kfree(key_device);
    return ret;
}

static void __exit workqueue_demo_exit(void)
{
    free_irq(key_device->irq, key_device);
    cancel_work_sync(&key_device->work);
    cancel_delayed_work_sync(&key_device->dwork);
    gpio_free(key_device->gpio);
    kfree(key_device);
    pr_info("Workqueue demo driver unloaded\n");
}

module_init(workqueue_demo_init);
module_exit(workqueue_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Workqueue Demo Driver");
```

---

### 3.4 线程化中断示例

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

#define GPIO_KEY    100

static int irq_num;

struct key_data {
    int gpio;
    int value;
};

static struct key_data key_info;

/* 上半部处理函数（硬中断上下文） */
static irqreturn_t key_irq_handler(int irq, void *dev_id)
{
    struct key_data *data = (struct key_data *)dev_id;
    
    /* 快速读取硬件状态 */
    data->value = gpio_get_value(data->gpio);
    
    /* 返回IRQ_WAKE_THREAD唤醒线程处理 */
    return IRQ_WAKE_THREAD;
}

/* 线程化处理函数（进程上下文，可以睡眠） */
static irqreturn_t key_thread_handler(int irq, void *dev_id)
{
    struct key_data *data = (struct key_data *)dev_id;
    
    /* 消抖延时 */
    msleep(20);
    
    /* 再次读取确认 */
    if (gpio_get_value(data->gpio) == data->value) {
        pr_info("Thread handler: Key %s\n", 
                data->value ? "released" : "pressed");
    }
    
    return IRQ_HANDLED;
}

static int __init threaded_irq_init(void)
{
    int ret;
    
    key_info.gpio = GPIO_KEY;
    
    ret = gpio_request(key_info.gpio, "key_gpio");
    if (ret)
        return ret;
    
    gpio_direction_input(key_info.gpio);
    
    irq_num = gpio_to_irq(key_info.gpio);
    if (irq_num < 0) {
        gpio_free(key_info.gpio);
        return irq_num;
    }
    
    /* 申请线程化中断 */
    ret = request_threaded_irq(irq_num,
                               key_irq_handler,      /* 上半部 */
                               key_thread_handler,   /* 线程处理函数 */
                               IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
                               "threaded_key",
                               &key_info);
    if (ret) {
        gpio_free(key_info.gpio);
        return ret;
    }
    
    pr_info("Threaded IRQ demo driver loaded\n");
    return 0;
}

static void __exit threaded_irq_exit(void)
{
    free_irq(irq_num, &key_info);
    gpio_free(key_info.gpio);
    pr_info("Threaded IRQ demo driver unloaded\n");
}

module_init(threaded_irq_init);
module_exit(threaded_irq_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Threaded IRQ Demo Driver");
```

---

### 3.5 设备树获取中断示例

**设备树节点定义：**
```dts
my_key {
    compatible = "my,gpio-key";
    interrupt-parent = <&gpio0>;
    interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
    gpios = <&gpio0 5 GPIO_ACTIVE_LOW>;
    status = "okay";
};
```

**驱动代码：**
```c
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/of_irq.h>
#include <linux/interrupt.h>
#include <linux/gpio/consumer.h>

struct my_key_dev {
    struct gpio_desc *gpio;
    int irq;
    int key_value;
};

static irqreturn_t my_key_irq_handler(int irq, void *dev_id)
{
    struct my_key_dev *dev = (struct my_key_dev *)dev_id;
    
    dev->key_value = gpiod_get_value(dev->gpio);
    pr_info("Key interrupt: value = %d\n", dev->key_value);
    
    return IRQ_HANDLED;
}

static int my_key_probe(struct platform_device *pdev)
{
    struct my_key_dev *dev;
    int ret;
    
    dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return -ENOMEM;
    
    /* 从设备树获取GPIO */
    dev->gpio = devm_gpiod_get(&pdev->dev, NULL, GPIOD_IN);
    if (IS_ERR(dev->gpio)) {
        dev_err(&pdev->dev, "Failed to get GPIO\n");
        return PTR_ERR(dev->gpio);
    }
    
    /* 方法1：从设备树获取中断号 */
    dev->irq = platform_get_irq(pdev, 0);
    if (dev->irq < 0) {
        dev_err(&pdev->dev, "Failed to get IRQ\n");
        return dev->irq;
    }
    
    /* 方法2：使用 irq_of_parse_and_map
    dev->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
    */
    
    /* 方法3：使用 gpiod_to_irq
    dev->irq = gpiod_to_irq(dev->gpio);
    */
    
    /* 申请中断（使用devm自动管理） */
    ret = devm_request_irq(&pdev->dev,
                           dev->irq,
                           my_key_irq_handler,
                           IRQF_TRIGGER_FALLING,
                           "my_key",
                           dev);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }
    
    platform_set_drvdata(pdev, dev);
    
    dev_info(&pdev->dev, "My key driver probed, IRQ = %d\n", dev->irq);
    return 0;
}

static int my_key_remove(struct platform_device *pdev)
{
    dev_info(&pdev->dev, "My key driver removed\n");
    return 0;
}

static const struct of_device_id my_key_of_match[] = {
    { .compatible = "my,gpio-key" },
    { }
};
MODULE_DEVICE_TABLE(of, my_key_of_match);

static struct platform_driver my_key_driver = {
    .probe  = my_key_probe,
    .remove = my_key_remove,
    .driver = {
        .name = "my_key",
        .of_match_table = my_key_of_match,
    },
};

module_platform_driver(my_key_driver);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Device Tree IRQ Demo Driver");
```

---

### 3.6 共享中断示例

```c
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>

#define SHARED_IRQ_NUM  50  /* 假设的共享中断号 */

struct device_data {
    int id;
    const char *name;
    /* 其他设备相关数据 */
};

static struct device_data dev1 = { .id = 1, .name = "device1" };
static struct device_data dev2 = { .id = 2, .name = "device2" };

/* 共享中断处理函数 */
static irqreturn_t shared_irq_handler(int irq, void *dev_id)
{
    struct device_data *dev = (struct device_data *)dev_id;
    
    /* 检查中断是否由本设备产生 */
    /* 这里需要读取硬件寄存器判断 */
    bool is_my_interrupt = true;  /* 假设判断结果 */
    
    if (!is_my_interrupt)
        return IRQ_NONE;  /* 不是我的中断 */
    
    pr_info("Shared IRQ handled by %s (id=%d)\n", dev->name, dev->id);
    
    /* 清除中断标志 */
    /* write_reg(INT_CLEAR, 1); */
    
    return IRQ_HANDLED;
}

static int __init shared_irq_init(void)
{
    int ret;
    
    /* 第一个设备申请共享中断 */
    ret = request_irq(SHARED_IRQ_NUM,
                      shared_irq_handler,
                      IRQF_SHARED,          /* 共享中断标志 */
                      "shared_irq_dev1",
                      &dev1);               /* 必须传入唯一的dev_id */
    if (ret) {
        pr_err("Device1 failed to request shared IRQ\n");
        return ret;
    }
    
    /* 第二个设备申请同一个共享中断 */
    ret = request_irq(SHARED_IRQ_NUM,
                      shared_irq_handler,
                      IRQF_SHARED,
                      "shared_irq_dev2",
                      &dev2);
    if (ret) {
        pr_err("Device2 failed to request shared IRQ\n");
        free_irq(SHARED_IRQ_NUM, &dev1);
        return ret;
    }
    
    pr_info("Shared IRQ demo driver loaded\n");
    return 0;
}

static void __exit shared_irq_exit(void)
{
    /* 释放时必须传入相同的dev_id */
    free_irq(SHARED_IRQ_NUM, &dev1);
    free_irq(SHARED_IRQ_NUM, &dev2);
    pr_info("Shared IRQ demo driver unloaded\n");
}

module_init(shared_irq_init);
module_exit(shared_irq_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Shared IRQ Demo Driver");
```

---

## 附录：中断调试方法

### 查看中断信息

```bash
# 查看所有中断统计
cat /proc/interrupts

# 查看特定中断的亲和性
cat /proc/irq/<irq_num>/smp_affinity

# 查看中断触发次数
cat /proc/irq/<irq_num>/spurious
```

### 设置中断亲和性

```bash
# 将中断绑定到CPU0
echo 1 > /proc/irq/<irq_num>/smp_affinity
```

### 常见问题排查

| 问题 | 可能原因 | 解决方法 |
|------|---------|---------|
| 中断不触发 | GPIO配置错误 | 检查GPIO方向、上下拉设置 |
| 中断频繁触发 | 未消抖或触发类型错误 | 添加消抖、调整触发类型 |
| 系统卡死 | 中断处理中死循环或睡眠 | 检查上半部代码，避免睡眠 |
| 共享中断问题 | dev_id为NULL | 共享中断必须传入唯一dev_id |
