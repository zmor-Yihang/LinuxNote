# Linux 内核原子操作 API 总结

## 一、概述

### 作用
原子操作（Atomic operations）在并发环境中对整型、位等进行不可分割的操作，避免竞态条件。主要用于：
- 计数器（引用计数、统计计数）
- 标志位管理
- 轻量级同步机制

### 适用场景
- ✅ 单个变量的轻量级同步
- ✅ 引用计数、统计计数
- ✅ 简单标记位操作
- ❌ **不适合**：需要多变量一致性或复杂顺序保证的场景（仍需使用锁或 RCU）

---

## 二、主要数据类型

| 类型 | 说明 |
|------|------|
| `atomic_t` | 用于存放整型（通常为 32 位或与架构字长相关）的原子变量 |
| `atomic64_t` | 用于 64 位原子操作（在 32 位架构上提供 64 位原子性支持） |
| `atomic_long_t` | 与平台字长匹配的原子类型 |

---

## 三、常用操作 API

### 3.1 读写操作

```c
atomic_t v;

// 读取原子变量的当前值
int val = atomic_read(&v);

// 设置原子变量的值
atomic_set(&v, 100);
```

### 3.2 基本算术操作

```c
// 自增/自减
atomic_inc(&v);        // v++
atomic_dec(&v);        // v--

// 加/减指定值
atomic_add(5, &v);     // v += 5
atomic_sub(3, &v);     // v -= 3
```

### 3.3 返回值变体

```c
// 自增/自减并返回新值
int new_val = atomic_inc_return(&v);
int new_val = atomic_dec_return(&v);

// 加/减并返回新值
int new_val = atomic_add_return(5, &v);
int new_val = atomic_sub_return(3, &v);

// 递减并测试是否为零（返回布尔值）
if (atomic_dec_and_test(&v)) {
    // v 递减后等于 0
}
```

### 3.4 条件操作

```c
// 仅当 v != u 时，v += a（常用于引用计数）
if (atomic_add_unless(&v, 1, 0)) {
    // 成功：v 原来不为 0，已加 1
}

// 仅当 v != 0 时自增（等价于 atomic_add_unless(&v, 1, 0)）
if (atomic_inc_not_zero(&v)) {
    // 成功：v 原来不为 0，已加 1
}
```

### 3.5 原子替换操作（CAS）

```c
// 比较并交换（Compare-And-Swap）
int old_val = atomic_cmpxchg(&v, old, new);
// 如果 v == old，则 v = new，返回旧值
// 典型用法：循环 CAS 更新
int old, new;
do {
    old = atomic_read(&v);
    new = compute_based_on(old);
} while (atomic_cmpxchg(&v, old, new) != old);

// 原子交换（无条件替换）
int old_val = atomic_xchg(&v, new);  // v = new, 返回旧值
```

### 3.6 位操作（原子位级操作）

```c
unsigned long flags;

// 设置/清除位
set_bit(nr, &flags);      // flags |= (1 << nr)
clear_bit(nr, &flags);    // flags &= ~(1 << nr)

// 测试并设置/清除位（返回旧的位值）
int old = test_and_set_bit(nr, &flags);
int old = test_and_clear_bit(nr, &flags);

// 测试位
if (test_bit(nr, &flags)) {
    // 第 nr 位为 1
}
```

### 3.7 64 位变体

所有上述操作都有对应的 64 位版本，用于 `atomic64_t` 类型：

```c
atomic64_t v64;

atomic64_read(&v64);
atomic64_set(&v64, val);
atomic64_inc(&v64);
atomic64_add_return(n, &v64);
atomic64_cmpxchg(&v64, old, new);
// ... 等等
```

---

## 四、内存顺序与语义

### 内存屏障
- 原子操作本身提供基本的原子性保证，但不同操作对内存顺序的保证程度不同
- 需要严格内存顺序时，结合使用：
  - `smp_mb()`：完全内存屏障
  - `smp_rmb()`：读屏障
  - `smp_wmb()`：写屏障

### 注意事项
- **单变量原子性**：原子操作仅保证单个变量的操作不可分割
- **多变量一致性**：跨多个变量的一致性仍需锁或 RCU 机制
- **ABA 问题**：在 CAS 循环中需注意 ABA 问题（值从 A→B→A，但中间状态已改变）

---

## 五、使用建议

### ✅ 推荐场景
1. **引用计数管理**
   ```c
   struct my_obj {
       atomic_t refcount;
       // ...
   };
   
   void get_obj(struct my_obj *obj) {
       atomic_inc(&obj->refcount);
   }
   
   void put_obj(struct my_obj *obj) {
       if (atomic_dec_and_test(&obj->refcount)) {
           kfree(obj);  // 引用计数归零，释放对象
       }
   }
   ```

2. **统计计数器**
   ```c
   static atomic_t packet_count = ATOMIC_INIT(0);
   
   void handle_packet(void) {
       atomic_inc(&packet_count);
       // 处理数据包...
   }
   ```

3. **标志位管理**
   ```c
   atomic_t state;
   #define STATE_RUNNING  0
   #define STATE_STOPPED  1
   
   if (atomic_cmpxchg(&state, STATE_STOPPED, STATE_RUNNING) == STATE_STOPPED) {
       // 成功从 STOPPED 切换到 RUNNING
   }
   ```

### ❌ 不推荐场景
- 多个变量需要同时更新且保持一致性
- 需要复杂的条件判断和多步操作
- 需要可重入或嵌套的同步保护

---

## 六、常见错误与调试

### 1. 误用场景
```c
// ❌ 错误：原子操作不能替代锁保护多变量
atomic_inc(&counter);
list_add(&node, &list);  // 竞态！需要锁保护

// ✅ 正确：使用锁
spin_lock(&lock);
counter++;
list_add(&node, &list);
spin_unlock(&lock);
```

### 2. 内存顺序问题
```c
// ❌ 可能有问题：依赖编译器优化顺序
atomic_set(&ready, 1);
data = compute();  // 可能被重排到 atomic_set 之前

// ✅ 正确：添加内存屏障
atomic_set(&ready, 1);
smp_wmb();  // 确保 ready 的写入对其他 CPU 可见
data = compute();
```

### 3. 32 位平台上的 64 位操作
```c
// ❌ 错误：32 位平台上直接操作 64 位变量不原子
u64 counter;
counter++;  // 非原子！

// ✅ 正确：使用 atomic64_t
atomic64_t counter;
atomic64_inc(&counter);
```

---

## 七、API 速查表

| 操作类别 | 函数 | 说明 |
|---------|------|------|
| **读写** | `atomic_read(&v)` | 读取值 |
| | `atomic_set(&v, val)` | 设置值 |
| **算术** | `atomic_inc(&v)` | 自增 |
| | `atomic_dec(&v)` | 自减 |
| | `atomic_add(n, &v)` | 加 n |
| | `atomic_sub(n, &v)` | 减 n |
| **带返回** | `atomic_inc_return(&v)` | 自增并返回新值 |
| | `atomic_dec_and_test(&v)` | 自减并测试是否为 0 |
| | `atomic_add_return(n, &v)` | 加 n 并返回新值 |
| **条件** | `atomic_add_unless(&v, a, u)` | v != u 时，v += a |
| | `atomic_inc_not_zero(&v)` | v != 0 时，v++ |
| **CAS** | `atomic_cmpxchg(&v, old, new)` | v == old 则 v = new，返回旧值 |
| | `atomic_xchg(&v, new)` | 无条件交换，返回旧值 |
| **位操作** | `set_bit(nr, &addr)` | 设置第 nr 位 |
| | `clear_bit(nr, &addr)` | 清除第 nr 位 |
| | `test_and_set_bit(nr, &addr)` | 测试并设置 |
| **64位** | `atomic64_*` | 所有操作的 64 位版本 |

---

## 八、参考资料

- Linux 内核源码：`include/linux/atomic.h`
- Linux 内核文档：`Documentation/atomic_ops.txt`
- 内核同步机制文档：`Documentation/memory-barriers.txt`

---

## 附录：完整示例

### 引用计数实现
```c
#include <linux/slab.h>
#include <linux/atomic.h>

struct my_device {
    atomic_t refcount;
    char name[32];
    // 其他字段...
};

struct my_device *device_create(const char *name) {
    struct my_device *dev;
    
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return NULL;
    
    strncpy(dev->name, name, sizeof(dev->name) - 1);
    atomic_set(&dev->refcount, 1);  // 初始引用计数为 1
    
    return dev;
}

void device_get(struct my_device *dev) {
    atomic_inc(&dev->refcount);
}

void device_put(struct my_device *dev) {
    if (atomic_dec_and_test(&dev->refcount)) {
        pr_info("Freeing device: %s\n", dev->name);
        kfree(dev);
    }
}
```

### CAS 循环更新
```c
atomic_t counter = ATOMIC_INIT(100);

void complex_update(void) {
    int old, new;
    
    do {
        old = atomic_read(&counter);
        
        // 复杂计算新值（基于旧值）
        if (old > 50)
            new = old * 2;
        else
            new = old + 10;
        
        // 尝试原子更新，失败则重试
    } while (atomic_cmpxchg(&counter, old, new) != old);
}
```

---

**最后更新日期**: 2025年11月24日
