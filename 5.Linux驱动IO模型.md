# Linux驱动IO模型

## 第一章：IO模型实现步骤

### 1.1 什么是IO模型

IO模型是指应用程序与内核之间进行数据传输的方式。在Linux驱动开发中，IO模型决定了用户空间如何等待和获取设备数据，直接影响系统的响应性能和资源利用率。

### 1.2 Linux五种IO模型

| IO模型 | 说明 | 特点 |
|--------|------|------|
| 阻塞IO | 进程调用read/write后阻塞，直到数据就绪 | 简单，但效率低 |
| 非阻塞IO | 调用立即返回，需应用层轮询检查数据状态 | 不阻塞，但CPU消耗大 |
| IO多路复用 | 使用select/poll/epoll同时监控多个fd | 高效处理多连接 |
| 信号驱动IO | 数据就绪时内核发送SIGIO信号 | 异步通知，实时性好 |
| 异步IO | 完全异步，内核完成整个IO操作后通知 | 真正的异步，效率最高 |

### 1.3 IO模型选择指南

| 场景 | 推荐模型 | 原因 |
|------|---------|------|
| 简单的单一设备访问 | 阻塞IO | 实现简单，代码清晰 |
| 需要同时做其他工作 | 非阻塞IO | 不会阻塞进程 |
| 监控多个设备 | IO多路复用 | 高效管理多个fd |
| 需要实时响应 | 信号驱动IO | 数据就绪立即通知 |
| GUI应用/高性能服务器 | 异步IO/epoll | 最大化并发性能 |

### 1.4 阻塞IO实现步骤

```
步骤一：定义等待队列头
    wait_queue_head_t wait_queue;
    ↓
步骤二：初始化等待队列
    init_waitqueue_head(&wait_queue);
    ↓
步骤三：在read/write中判断条件，不满足则等待
    wait_event_interruptible(wait_queue, condition);
    ↓
步骤四：在数据就绪时（如中断中）唤醒等待队列
    wake_up_interruptible(&wait_queue);
```

### 1.5 非阻塞IO实现步骤

```
步骤一：在open中设置或检查O_NONBLOCK标志
    filp->f_flags & O_NONBLOCK
    ↓
步骤二：在read/write中判断数据是否就绪
    ↓
步骤三：若数据未就绪且为非阻塞模式
    返回 -EAGAIN 或 -EWOULDBLOCK
    ↓
步骤四：应用层循环调用read直到成功
```

### 1.6 IO多路复用实现步骤（poll机制）

```
步骤一：在驱动中实现poll函数
    static unsigned int xxx_poll(struct file *filp, poll_table *wait);
    ↓
步骤二：调用poll_wait将等待队列添加到poll_table
    poll_wait(filp, &wait_queue, wait);
    ↓
步骤三：返回当前可进行的操作掩码
    返回 POLLIN | POLLRDNORM（可读）
    返回 POLLOUT | POLLWRNORM（可写）
    ↓
步骤四：应用层使用select/poll/epoll监控文件描述符
```

### 1.7 异步通知（信号驱动IO）实现步骤

```
步骤一：在设备结构中定义fasync_struct指针
    struct fasync_struct *async_queue;
    ↓
步骤二：实现fasync函数，调用fasync_helper
    fasync_helper(fd, filp, on, &dev->async_queue);
    ↓
步骤三：在release中清理fasync
    xxx_fasync(-1, filp, 0);
    ↓
步骤四：数据就绪时发送SIGIO信号
    kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    ↓
步骤五：应用层设置信号处理和文件属性
    fcntl(fd, F_SETOWN, getpid());
    fcntl(fd, F_SETFL, flags | FASYNC);
```

---

## 第二章：常用结构体与函数速查

### 2.1 等待队列

#### `wait_queue_head_t` - 等待队列头结构体
```c
typedef struct wait_queue_head {
    spinlock_t lock;
    struct list_head head;
} wait_queue_head_t;

// 静态初始化
DECLARE_WAIT_QUEUE_HEAD(name);
// 动态初始化
wait_queue_head_t wait_queue;
init_waitqueue_head(&wait_queue);
```

#### `init_waitqueue_head` - 初始化等待队列头
```c
void init_waitqueue_head(wait_queue_head_t *q);
```

#### `wait_event` - 无条件等待（不可中断）
```c
void wait_event(wait_queue_head_t *q, int condition);
```

#### `wait_event_interruptible` - 可中断等待
```c
int wait_event_interruptible(wait_queue_head_t *q, int condition);
// 返回0表示条件满足，返回非0表示被信号中断
```

#### `wait_event_timeout` - 带超时的等待
```c
long wait_event_timeout(wait_queue_head_t *q, int condition, long timeout);
// timeout单位为jiffies，返回0表示超时，返回剩余时间表示条件满足
```

#### `wait_event_interruptible_timeout` - 可中断的超时等待
```c
long wait_event_interruptible_timeout(wait_queue_head_t *q, 
                                       int condition, long timeout);
// 返回0超时，返回负值被中断，返回正值表示剩余时间
```

#### `wake_up` - 唤醒等待队列（所有）
```c
void wake_up(wait_queue_head_t *q);
```

#### `wake_up_interruptible` - 唤醒可中断等待的进程
```c
void wake_up_interruptible(wait_queue_head_t *q);
```

#### `wake_up_all` - 唤醒所有等待进程
```c
void wake_up_all(wait_queue_head_t *q);
```

#### `wake_up_interruptible_all` - 唤醒所有可中断等待进程
```c
void wake_up_interruptible_all(wait_queue_head_t *q);
```

---

### 2.2 Poll机制

#### `poll_table` - poll表结构体
```c
typedef struct poll_table_struct {
    poll_queue_proc _qproc;
    __poll_t _key;
} poll_table;
// 由内核在select/poll/epoll调用时自动创建和管理
```

#### `poll_wait` - 将等待队列添加到poll_table
```c
void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table *wait);
// 注意：此函数不会阻塞，仅将队列加入监控列表
```

#### Poll返回掩码常量
```c
/* 可读事件 */
#define POLLIN      0x0001  /* 有数据可读 */
#define POLLRDNORM  0x0040  /* 有普通数据可读 */
#define POLLRDBAND  0x0080  /* 有优先数据可读 */
#define POLLPRI     0x0002  /* 有紧急数据可读 */

/* 可写事件 */
#define POLLOUT     0x0004  /* 可以写数据 */
#define POLLWRNORM  0x0100  /* 可以写普通数据 */
#define POLLWRBAND  0x0200  /* 可以写优先数据 */

/* 错误事件 */
#define POLLERR     0x0008  /* 发生错误 */
#define POLLHUP     0x0010  /* 挂起 */
#define POLLNVAL    0x0020  /* 无效的请求 */
```

---

### 2.3 异步通知（fasync）

#### `fasync_struct` - 异步通知结构体
```c
struct fasync_struct {
    rwlock_t fa_lock;
    int magic;
    int fa_fd;
    struct fasync_struct *fa_next;
    struct file *fa_file;
    struct rcu_head fa_rcu;
};
// 在设备结构体中定义指针
struct fasync_struct *async_queue;
```

#### `fasync_helper` - 初始化/释放fasync队列
```c
int fasync_helper(int fd, struct file *filp, int on, 
                  struct fasync_struct **fapp);
// on=1 添加到队列，on=0 从队列移除
// 成功返回>=0，失败返回负值
```

#### `kill_fasync` - 发送信号给异步通知进程
```c
void kill_fasync(struct fasync_struct **fp, int sig, int band);
// sig: 通常为SIGIO
// band: POLL_IN（可读）, POLL_OUT（可写）, POLL_ERR（错误）等
```

---

### 2.4 Select/Poll/Epoll（用户空间）

#### `fd_set` - 文件描述符集合
```c
typedef struct {
    unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} fd_set;

/* fd_set操作宏 */
FD_ZERO(fd_set *set);           /* 清空集合 */
FD_SET(int fd, fd_set *set);    /* 添加fd到集合 */
FD_CLR(int fd, fd_set *set);    /* 从集合移除fd */
FD_ISSET(int fd, fd_set *set);  /* 检查fd是否在集合中 */
```

#### `select` - 同步IO多路复用
```c
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
// nfds: 最大fd+1
// 返回就绪的fd数量，0表示超时，-1表示错误
```

#### `pollfd` - poll文件描述符结构体
```c
struct pollfd {
    int   fd;         /* 文件描述符 */
    short events;     /* 等待的事件 */
    short revents;    /* 实际发生的事件 */
};
```

#### `poll` - 同步IO多路复用（改进版）
```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// timeout: 毫秒，-1表示无限等待，0表示立即返回
```

#### `epoll_event` - epoll事件结构体
```c
struct epoll_event {
    uint32_t events;    /* EPOLLIN, EPOLLOUT, EPOLLET等 */
    epoll_data_t data;  /* 用户数据 */
};

typedef union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
```

#### `epoll_create` - 创建epoll实例
```c
int epoll_create(int size);      // size已被忽略，但必须>0
int epoll_create1(int flags);    // flags: 0 或 EPOLL_CLOEXEC
// 返回epoll文件描述符
```

#### `epoll_ctl` - 控制epoll实例
```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// op: EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL
```

#### `epoll_wait` - 等待epoll事件
```c
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
// 返回就绪事件数量
```

---

### 2.5 定时与延时

#### `timer_list` - 内核定时器结构体
```c
struct timer_list {
    struct hlist_node entry;
    unsigned long expires;      /* 到期时间（jiffies） */
    void (*function)(struct timer_list *);  /* 回调函数 */
    u32 flags;
};

// 初始化定时器
timer_setup(&timer, callback_func, 0);
```

#### `schedule_timeout` - 让出CPU并等待超时
```c
long schedule_timeout(long timeout);
// 需要先设置进程状态：set_current_state(TASK_INTERRUPTIBLE);
// 返回剩余的jiffies
```

#### `msleep` - 毫秒级睡眠（不可中断）
```c
void msleep(unsigned int msecs);
```

#### `msleep_interruptible` - 可中断的毫秒级睡眠
```c
unsigned long msleep_interruptible(unsigned int msecs);
// 返回剩余的毫秒数
```

#### `usleep_range` - 微秒级睡眠
```c
void usleep_range(unsigned long min, unsigned long max);
// 推荐用于精确的微秒级延时
```

---

### 2.6 工作队列（延迟执行）

#### `work_struct` - 工作项结构体
```c
struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
};

// 初始化
INIT_WORK(&work, work_handler);
```

#### `delayed_work` - 延迟工作项结构体
```c
struct delayed_work {
    struct work_struct work;
    struct timer_list timer;
};

// 初始化
INIT_DELAYED_WORK(&dwork, work_handler);
```

#### `INIT_WORK` - 初始化工作项
```c
INIT_WORK(struct work_struct *work, work_func_t func);
```

#### `schedule_work` - 调度工作到系统工作队列
```c
bool schedule_work(struct work_struct *work);
```

#### `schedule_delayed_work` - 延迟调度工作
```c
bool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);
// delay: jiffies
```

#### `cancel_work_sync` - 取消工作并等待完成
```c
bool cancel_work_sync(struct work_struct *work);
```

#### `flush_work` - 等待工作完成
```c
bool flush_work(struct work_struct *work);
```

---

## 第三章：示例代码

### 3.1 阻塞IO示例 - 等待队列实现

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/sched.h>

#define DEVICE_NAME "blocking_io"
#define BUF_SIZE    256

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct block_dev {
    wait_queue_head_t read_queue;   /* 读等待队列 */
    wait_queue_head_t write_queue;  /* 写等待队列 */
    char buffer[BUF_SIZE];
    int data_len;
    struct mutex lock;
};

static struct block_dev *bdev;

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = bdev;
    pr_info("blocking_io: device opened\n");
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct block_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    /* 等待数据可用 */
    while (dev->data_len == 0) {
        mutex_unlock(&dev->lock);
        
        /* 非阻塞模式直接返回 */
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        pr_info("blocking_io: read waiting...\n");
        
        /* 阻塞等待，直到有数据或被信号中断 */
        if (wait_event_interruptible(dev->read_queue, dev->data_len > 0))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    /* 读取数据 */
    if (count > dev->data_len)
        count = dev->data_len;
    
    if (copy_to_user(buf, dev->buffer, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    /* 移动剩余数据 */
    memmove(dev->buffer, dev->buffer + count, dev->data_len - count);
    dev->data_len -= count;
    
    mutex_unlock(&dev->lock);
    
    /* 唤醒可能等待写入的进程 */
    wake_up_interruptible(&dev->write_queue);
    
    pr_info("blocking_io: read %zu bytes\n", count);
    return count;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct block_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    /* 等待缓冲区有空间 */
    while (dev->data_len >= BUF_SIZE) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        pr_info("blocking_io: write waiting...\n");
        
        if (wait_event_interruptible(dev->write_queue, 
                                      dev->data_len < BUF_SIZE))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    /* 写入数据 */
    if (count > BUF_SIZE - dev->data_len)
        count = BUF_SIZE - dev->data_len;
    
    if (copy_from_user(dev->buffer + dev->data_len, buf, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    dev->data_len += count;
    
    mutex_unlock(&dev->lock);
    
    /* 唤醒等待读取的进程 */
    wake_up_interruptible(&dev->read_queue);
    
    pr_info("blocking_io: wrote %zu bytes\n", count);
    return count;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = my_read,
    .write   = my_write,
};

static int __init blocking_io_init(void)
{
    int ret;
    
    bdev = kzalloc(sizeof(*bdev), GFP_KERNEL);
    if (!bdev)
        return -ENOMEM;
    
    /* 初始化等待队列 */
    init_waitqueue_head(&bdev->read_queue);
    init_waitqueue_head(&bdev->write_queue);
    mutex_init(&bdev->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("blocking_io: driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(bdev);
    return ret;
}

static void __exit blocking_io_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(bdev);
    pr_info("blocking_io: driver unloaded\n");
}

module_init(blocking_io_init);
module_exit(blocking_io_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Blocking IO demo driver");
```

---

### 3.2 Poll机制示例 - IO多路复用

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/poll.h>

#define DEVICE_NAME "poll_demo"
#define BUF_SIZE    256

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct poll_dev {
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;
    char buffer[BUF_SIZE];
    int data_len;
    struct mutex lock;
};

static struct poll_dev *pdev;

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = pdev;
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct poll_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    while (dev->data_len == 0) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        if (wait_event_interruptible(dev->read_queue, dev->data_len > 0))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    if (count > dev->data_len)
        count = dev->data_len;
    
    if (copy_to_user(buf, dev->buffer, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    memmove(dev->buffer, dev->buffer + count, dev->data_len - count);
    dev->data_len -= count;
    
    mutex_unlock(&dev->lock);
    wake_up_interruptible(&dev->write_queue);
    
    return count;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct poll_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    while (dev->data_len >= BUF_SIZE) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        if (wait_event_interruptible(dev->write_queue, 
                                      dev->data_len < BUF_SIZE))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    if (count > BUF_SIZE - dev->data_len)
        count = BUF_SIZE - dev->data_len;
    
    if (copy_from_user(dev->buffer + dev->data_len, buf, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    dev->data_len += count;
    
    mutex_unlock(&dev->lock);
    wake_up_interruptible(&dev->read_queue);
    
    return count;
}

/* poll函数实现 */
static unsigned int my_poll(struct file *filp, poll_table *wait)
{
    struct poll_dev *dev = filp->private_data;
    unsigned int mask = 0;
    
    mutex_lock(&dev->lock);
    
    /* 将等待队列添加到poll_table，不会阻塞 */
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    /* 检查可读条件 */
    if (dev->data_len > 0)
        mask |= POLLIN | POLLRDNORM;    /* 可读 */
    
    /* 检查可写条件 */
    if (dev->data_len < BUF_SIZE)
        mask |= POLLOUT | POLLWRNORM;   /* 可写 */
    
    mutex_unlock(&dev->lock);
    
    return mask;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = my_read,
    .write   = my_write,
    .poll    = my_poll,     /* 实现poll方法 */
};

static int __init poll_demo_init(void)
{
    int ret;
    
    pdev = kzalloc(sizeof(*pdev), GFP_KERNEL);
    if (!pdev)
        return -ENOMEM;
    
    init_waitqueue_head(&pdev->read_queue);
    init_waitqueue_head(&pdev->write_queue);
    mutex_init(&pdev->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("poll_demo: driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(pdev);
    return ret;
}

static void __exit poll_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(pdev);
    pr_info("poll_demo: driver unloaded\n");
}

module_init(poll_demo_init);
module_exit(poll_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Poll mechanism demo driver");
```

**用户空间测试程序（使用select）：**

```c
/* user_select_test.c */
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>
#include <string.h>

int main(void)
{
    int fd;
    fd_set readfds, writefds;
    struct timeval timeout;
    char buf[256];
    int ret;
    
    fd = open("/dev/poll_demo", O_RDWR);
    if (fd < 0) {
        perror("open");
        return -1;
    }
    
    while (1) {
        FD_ZERO(&readfds);
        FD_ZERO(&writefds);
        FD_SET(fd, &readfds);
        FD_SET(fd, &writefds);
        
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        
        ret = select(fd + 1, &readfds, &writefds, NULL, &timeout);
        
        if (ret < 0) {
            perror("select");
            break;
        } else if (ret == 0) {
            printf("Timeout, no data\n");
            continue;
        }
        
        if (FD_ISSET(fd, &readfds)) {
            memset(buf, 0, sizeof(buf));
            ret = read(fd, buf, sizeof(buf));
            if (ret > 0)
                printf("Read: %s\n", buf);
        }
        
        if (FD_ISSET(fd, &writefds)) {
            printf("Device is writable\n");
        }
    }
    
    close(fd);
    return 0;
}
```

**用户空间测试程序（使用epoll）：**

```c
/* user_epoll_test.c */
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <string.h>

#define MAX_EVENTS 10

int main(void)
{
    int fd, epfd;
    struct epoll_event ev, events[MAX_EVENTS];
    char buf[256];
    int ret, n;
    
    fd = open("/dev/poll_demo", O_RDWR | O_NONBLOCK);
    if (fd < 0) {
        perror("open");
        return -1;
    }
    
    /* 创建epoll实例 */
    epfd = epoll_create1(0);
    if (epfd < 0) {
        perror("epoll_create1");
        close(fd);
        return -1;
    }
    
    /* 添加fd到epoll */
    ev.events = EPOLLIN | EPOLLOUT;
    ev.data.fd = fd;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) < 0) {
        perror("epoll_ctl");
        close(fd);
        close(epfd);
        return -1;
    }
    
    while (1) {
        n = epoll_wait(epfd, events, MAX_EVENTS, 5000);
        
        if (n < 0) {
            perror("epoll_wait");
            break;
        } else if (n == 0) {
            printf("Timeout\n");
            continue;
        }
        
        for (int i = 0; i < n; i++) {
            if (events[i].events & EPOLLIN) {
                memset(buf, 0, sizeof(buf));
                ret = read(events[i].data.fd, buf, sizeof(buf));
                if (ret > 0)
                    printf("Read: %s\n", buf);
            }
            
            if (events[i].events & EPOLLOUT) {
                printf("Device is writable\n");
            }
        }
    }
    
    close(fd);
    close(epfd);
    return 0;
}
```

---

### 3.3 异步通知示例 - fasync机制

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/poll.h>

#define DEVICE_NAME "fasync_demo"
#define BUF_SIZE    256

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct fasync_dev {
    wait_queue_head_t read_queue;
    struct fasync_struct *async_queue;  /* 异步通知队列 */
    char buffer[BUF_SIZE];
    int data_len;
    struct mutex lock;
};

static struct fasync_dev *fdev;

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = fdev;
    return 0;
}

/* fasync方法实现 */
static int my_fasync(int fd, struct file *filp, int on)
{
    struct fasync_dev *dev = filp->private_data;
    
    /* 使用fasync_helper管理异步通知队列 */
    return fasync_helper(fd, filp, on, &dev->async_queue);
}

static int my_release(struct inode *inode, struct file *filp)
{
    /* 关闭时清理异步通知 */
    my_fasync(-1, filp, 0);
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct fasync_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    while (dev->data_len == 0) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        if (wait_event_interruptible(dev->read_queue, dev->data_len > 0))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    if (count > dev->data_len)
        count = dev->data_len;
    
    if (copy_to_user(buf, dev->buffer, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    memmove(dev->buffer, dev->buffer + count, dev->data_len - count);
    dev->data_len -= count;
    
    mutex_unlock(&dev->lock);
    
    return count;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct fasync_dev *dev = filp->private_data;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    if (count > BUF_SIZE - dev->data_len)
        count = BUF_SIZE - dev->data_len;
    
    if (count == 0) {
        mutex_unlock(&dev->lock);
        return -ENOSPC;
    }
    
    if (copy_from_user(dev->buffer + dev->data_len, buf, count)) {
        mutex_unlock(&dev->lock);
        return -EFAULT;
    }
    
    dev->data_len += count;
    
    mutex_unlock(&dev->lock);
    
    /* 唤醒阻塞读取的进程 */
    wake_up_interruptible(&dev->read_queue);
    
    /* 发送SIGIO信号给注册了异步通知的进程 */
    if (dev->async_queue)
        kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    
    pr_info("fasync_demo: wrote %zu bytes, signal sent\n", count);
    return count;
}

static unsigned int my_poll(struct file *filp, poll_table *wait)
{
    struct fasync_dev *dev = filp->private_data;
    unsigned int mask = 0;
    
    mutex_lock(&dev->lock);
    
    poll_wait(filp, &dev->read_queue, wait);
    
    if (dev->data_len > 0)
        mask |= POLLIN | POLLRDNORM;
    
    if (dev->data_len < BUF_SIZE)
        mask |= POLLOUT | POLLWRNORM;
    
    mutex_unlock(&dev->lock);
    
    return mask;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .release = my_release,
    .read    = my_read,
    .write   = my_write,
    .poll    = my_poll,
    .fasync  = my_fasync,   /* 实现fasync方法 */
};

static int __init fasync_demo_init(void)
{
    int ret;
    
    fdev = kzalloc(sizeof(*fdev), GFP_KERNEL);
    if (!fdev)
        return -ENOMEM;
    
    init_waitqueue_head(&fdev->read_queue);
    mutex_init(&fdev->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("fasync_demo: driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(fdev);
    return ret;
}

static void __exit fasync_demo_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(fdev);
    pr_info("fasync_demo: driver unloaded\n");
}

module_init(fasync_demo_init);
module_exit(fasync_demo_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Fasync demo driver");
```

**用户空间测试程序（异步通知）：**

```c
/* user_fasync_test.c */
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

static int fd;

/* SIGIO信号处理函数 */
void sigio_handler(int signum)
{
    char buf[256];
    int ret;
    
    printf("Received SIGIO signal!\n");
    
    memset(buf, 0, sizeof(buf));
    ret = read(fd, buf, sizeof(buf));
    if (ret > 0)
        printf("Async read: %s\n", buf);
}

int main(void)
{
    int flags;
    
    fd = open("/dev/fasync_demo", O_RDWR);
    if (fd < 0) {
        perror("open");
        return -1;
    }
    
    /* 设置信号处理函数 */
    signal(SIGIO, sigio_handler);
    
    /* 设置文件拥有者为当前进程 */
    fcntl(fd, F_SETOWN, getpid());
    
    /* 获取当前文件标志 */
    flags = fcntl(fd, F_GETFL);
    
    /* 启用异步通知 */
    fcntl(fd, F_SETFL, flags | FASYNC);
    
    printf("Waiting for async notification...\n");
    printf("Use another terminal to write to /dev/fasync_demo\n");
    
    /* 主循环等待信号 */
    while (1) {
        sleep(1);
        printf(".");
        fflush(stdout);
    }
    
    close(fd);
    return 0;
}
```

---

### 3.4 定时器与延时IO示例

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/timer.h>
#include <linux/wait.h>

#define DEVICE_NAME "timer_io"

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct timer_dev {
    struct timer_list timer;
    wait_queue_head_t wait_queue;
    int data_ready;
    int timer_count;
    spinlock_t lock;
};

static struct timer_dev *tdev;

/* 定时器回调函数 */
static void timer_callback(struct timer_list *t)
{
    struct timer_dev *dev = from_timer(dev, t, timer);
    unsigned long flags;
    
    spin_lock_irqsave(&dev->lock, flags);
    dev->timer_count++;
    dev->data_ready = 1;
    spin_unlock_irqrestore(&dev->lock, flags);
    
    /* 唤醒等待的进程 */
    wake_up_interruptible(&dev->wait_queue);
    
    pr_info("timer_io: timer fired, count=%d\n", dev->timer_count);
    
    /* 重新启动定时器，每秒触发一次 */
    mod_timer(&dev->timer, jiffies + HZ);
}

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = tdev;
    
    /* 启动定时器 */
    mod_timer(&tdev->timer, jiffies + HZ);
    
    pr_info("timer_io: device opened, timer started\n");
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    /* 停止定时器 */
    del_timer_sync(&tdev->timer);
    pr_info("timer_io: device closed, timer stopped\n");
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct timer_dev *dev = filp->private_data;
    unsigned long flags;
    char tmp[32];
    int len;
    int timer_val;
    
    /* 等待定时器触发 */
    spin_lock_irqsave(&dev->lock, flags);
    while (!dev->data_ready) {
        spin_unlock_irqrestore(&dev->lock, flags);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        if (wait_event_interruptible(dev->wait_queue, dev->data_ready))
            return -ERESTARTSYS;
        
        spin_lock_irqsave(&dev->lock, flags);
    }
    
    timer_val = dev->timer_count;
    dev->data_ready = 0;
    spin_unlock_irqrestore(&dev->lock, flags);
    
    /* 返回定时器计数 */
    len = snprintf(tmp, sizeof(tmp), "Timer count: %d\n", timer_val);
    
    if (count < len)
        len = count;
    
    if (copy_to_user(buf, tmp, len))
        return -EFAULT;
    
    return len;
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .release = my_release,
    .read    = my_read,
};

static int __init timer_io_init(void)
{
    int ret;
    
    tdev = kzalloc(sizeof(*tdev), GFP_KERNEL);
    if (!tdev)
        return -ENOMEM;
    
    spin_lock_init(&tdev->lock);
    init_waitqueue_head(&tdev->wait_queue);
    
    /* 初始化定时器 */
    timer_setup(&tdev->timer, timer_callback, 0);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("timer_io: driver loaded\n");
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(tdev);
    return ret;
}

static void __exit timer_io_exit(void)
{
    del_timer_sync(&tdev->timer);
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    kfree(tdev);
    pr_info("timer_io: driver unloaded\n");
}

module_init(timer_io_init);
module_exit(timer_io_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Timer-based IO demo driver");
```

---

### 3.5 综合示例 - 完整的IO模型驱动

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/poll.h>
#include <linux/sched/signal.h>

#define DEVICE_NAME "complete_io"
#define BUF_SIZE    1024

static dev_t dev_num;
static struct cdev my_cdev;
static struct class *my_class;

struct complete_dev {
    /* 等待队列 */
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;
    
    /* 异步通知 */
    struct fasync_struct *async_queue;
    
    /* 环形缓冲区 */
    char buffer[BUF_SIZE];
    int read_pos;
    int write_pos;
    int data_len;
    
    /* 同步机制 */
    struct mutex lock;
    
    /* 统计信息 */
    unsigned long read_count;
    unsigned long write_count;
};

static struct complete_dev *cdev_data;

/* 获取可读数据长度 */
static inline int get_readable(struct complete_dev *dev)
{
    return dev->data_len;
}

/* 获取可写空间长度 */
static inline int get_writable(struct complete_dev *dev)
{
    return BUF_SIZE - dev->data_len;
}

static int my_open(struct inode *inode, struct file *filp)
{
    filp->private_data = cdev_data;
    pr_info("complete_io: opened\n");
    return 0;
}

static int my_fasync(int fd, struct file *filp, int on)
{
    struct complete_dev *dev = filp->private_data;
    return fasync_helper(fd, filp, on, &dev->async_queue);
}

static int my_release(struct inode *inode, struct file *filp)
{
    my_fasync(-1, filp, 0);
    pr_info("complete_io: closed\n");
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *buf,
                       size_t count, loff_t *f_pos)
{
    struct complete_dev *dev = filp->private_data;
    ssize_t ret = 0;
    size_t to_read;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    /* 等待数据可用 */
    while (get_readable(dev) == 0) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        pr_info("complete_io: read blocked\n");
        
        if (wait_event_interruptible(dev->read_queue, get_readable(dev) > 0))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    /* 计算实际读取长度 */
    to_read = min(count, (size_t)get_readable(dev));
    
    /* 从环形缓冲区读取 */
    if (dev->read_pos + to_read <= BUF_SIZE) {
        if (copy_to_user(buf, dev->buffer + dev->read_pos, to_read)) {
            ret = -EFAULT;
            goto out;
        }
    } else {
        size_t first = BUF_SIZE - dev->read_pos;
        if (copy_to_user(buf, dev->buffer + dev->read_pos, first)) {
            ret = -EFAULT;
            goto out;
        }
        if (copy_to_user(buf + first, dev->buffer, to_read - first)) {
            ret = -EFAULT;
            goto out;
        }
    }
    
    dev->read_pos = (dev->read_pos + to_read) % BUF_SIZE;
    dev->data_len -= to_read;
    dev->read_count++;
    ret = to_read;
    
out:
    mutex_unlock(&dev->lock);
    
    /* 唤醒等待写入的进程 */
    if (ret > 0)
        wake_up_interruptible(&dev->write_queue);
    
    return ret;
}

static ssize_t my_write(struct file *filp, const char __user *buf,
                        size_t count, loff_t *f_pos)
{
    struct complete_dev *dev = filp->private_data;
    ssize_t ret = 0;
    size_t to_write;
    
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    /* 等待有空间可写 */
    while (get_writable(dev) == 0) {
        mutex_unlock(&dev->lock);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        pr_info("complete_io: write blocked\n");
        
        if (wait_event_interruptible(dev->write_queue, get_writable(dev) > 0))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->lock))
            return -ERESTARTSYS;
    }
    
    /* 计算实际写入长度 */
    to_write = min(count, (size_t)get_writable(dev));
    
    /* 写入环形缓冲区 */
    if (dev->write_pos + to_write <= BUF_SIZE) {
        if (copy_from_user(dev->buffer + dev->write_pos, buf, to_write)) {
            ret = -EFAULT;
            goto out;
        }
    } else {
        size_t first = BUF_SIZE - dev->write_pos;
        if (copy_from_user(dev->buffer + dev->write_pos, buf, first)) {
            ret = -EFAULT;
            goto out;
        }
        if (copy_from_user(dev->buffer, buf + first, to_write - first)) {
            ret = -EFAULT;
            goto out;
        }
    }
    
    dev->write_pos = (dev->write_pos + to_write) % BUF_SIZE;
    dev->data_len += to_write;
    dev->write_count++;
    ret = to_write;
    
out:
    mutex_unlock(&dev->lock);
    
    if (ret > 0) {
        /* 唤醒等待读取的进程 */
        wake_up_interruptible(&dev->read_queue);
        
        /* 发送异步通知 */
        if (dev->async_queue)
            kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    }
    
    return ret;
}

static unsigned int my_poll(struct file *filp, poll_table *wait)
{
    struct complete_dev *dev = filp->private_data;
    unsigned int mask = 0;
    
    mutex_lock(&dev->lock);
    
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    if (get_readable(dev) > 0)
        mask |= POLLIN | POLLRDNORM;
    
    if (get_writable(dev) > 0)
        mask |= POLLOUT | POLLWRNORM;
    
    mutex_unlock(&dev->lock);
    
    return mask;
}

/* ioctl - 获取状态信息 */
static long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct complete_dev *dev = filp->private_data;
    int ret = 0;
    
    switch (cmd) {
    case 0: /* 获取可读数据量 */
        mutex_lock(&dev->lock);
        ret = get_readable(dev);
        mutex_unlock(&dev->lock);
        break;
    case 1: /* 获取可写空间 */
        mutex_lock(&dev->lock);
        ret = get_writable(dev);
        mutex_unlock(&dev->lock);
        break;
    case 2: /* 清空缓冲区 */
        mutex_lock(&dev->lock);
        dev->read_pos = 0;
        dev->write_pos = 0;
        dev->data_len = 0;
        mutex_unlock(&dev->lock);
        wake_up_interruptible(&dev->write_queue);
        break;
    default:
        ret = -EINVAL;
    }
    
    return ret;
}

static struct file_operations fops = {
    .owner          = THIS_MODULE,
    .open           = my_open,
    .release        = my_release,
    .read           = my_read,
    .write          = my_write,
    .poll           = my_poll,
    .fasync         = my_fasync,
    .unlocked_ioctl = my_ioctl,
};

static int __init complete_io_init(void)
{
    int ret;
    
    cdev_data = kzalloc(sizeof(*cdev_data), GFP_KERNEL);
    if (!cdev_data)
        return -ENOMEM;
    
    init_waitqueue_head(&cdev_data->read_queue);
    init_waitqueue_head(&cdev_data->write_queue);
    mutex_init(&cdev_data->lock);
    
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0)
        goto fail_region;
    
    cdev_init(&my_cdev, &fops);
    ret = cdev_add(&my_cdev, dev_num, 1);
    if (ret < 0)
        goto fail_cdev;
    
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        goto fail_class;
    }
    
    device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    pr_info("complete_io: driver loaded, major=%d\n", MAJOR(dev_num));
    return 0;

fail_class:
    cdev_del(&my_cdev);
fail_cdev:
    unregister_chrdev_region(dev_num, 1);
fail_region:
    kfree(cdev_data);
    return ret;
}

static void __exit complete_io_exit(void)
{
    device_destroy(my_class, dev_num);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    
    pr_info("complete_io: stats - reads=%lu, writes=%lu\n",
            cdev_data->read_count, cdev_data->write_count);
    
    kfree(cdev_data);
    pr_info("complete_io: driver unloaded\n");
}

module_init(complete_io_init);
module_exit(complete_io_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Complete IO model demo driver");
```

---

## 附录：头文件汇总

```c
#include <linux/wait.h>         /* 等待队列: wait_queue_head_t, wait_event */
#include <linux/poll.h>         /* Poll机制: poll_wait, POLLIN, POLLOUT */
#include <linux/sched.h>        /* 调度相关: schedule, set_current_state */
#include <linux/sched/signal.h> /* 信号相关: signal_pending */
#include <linux/timer.h>        /* 定时器: timer_list, timer_setup */
#include <linux/delay.h>        /* 延时: msleep, usleep_range */
#include <linux/workqueue.h>    /* 工作队列: work_struct, schedule_work */
#include <linux/fs.h>           /* 文件操作: fasync_struct, fasync_helper */
```

---

## 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| read永久阻塞 | 条件永远不满足或忘记唤醒 | 检查wake_up调用和条件判断 |
| poll返回但read仍阻塞 | poll和read条件不一致 | 确保poll返回掩码与实际状态一致 |
| SIGIO信号未收到 | 未正确设置F_SETOWN或FASYNC | 检查用户空间fcntl调用 |
| select返回错误fd数 | poll函数实现有误 | 检查poll_wait和返回mask |
| 非阻塞返回-EAGAIN | 数据未就绪 | 这是正常行为，应用层需循环检查 |
| 死锁 | 持锁时调用wait_event | wait前必须释放锁 |
| 数据丢失 | 环形缓冲区溢出 | 正确处理缓冲区满的情况 |
