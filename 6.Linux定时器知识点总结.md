# Linux定时器驱动开发总结

## 第一章 定时器开发步骤

### 1.1 定时器概述

Linux内核提供了定时器机制，用于在指定时间后执行特定的回调函数。定时器是一种"软中断"，运行在中断上下文中。

| 定时器类型 | 特点 | 精度 | 适用场景 |
|-----------|------|------|----------|
| 低精度定时器 | 基于jiffies，简单易用 | 毫秒级（取决于HZ） | 一般延时任务 |
| 高精度定时器 | 基于ktime，精度更高 | 纳秒级 | 精确定时需求 |

### 1.2 内核时间单位

#### jiffies - 内核节拍计数器
- `jiffies`：系统启动以来的节拍数
- `HZ`：每秒的节拍数（通常为100、250、1000）
- 时间换算：`1秒 = HZ个jiffies`

#### 常用时间转换
```
毫秒转jiffies：msecs_to_jiffies(ms)
微秒转jiffies：usecs_to_jiffies(us)
jiffies转毫秒：jiffies_to_msecs(j)
jiffies转微秒：jiffies_to_usecs(j)
```

### 1.3 低精度定时器使用步骤

#### 步骤1：定义定时器结构体
- 使用 `struct timer_list` 定义定时器变量
- 可以作为全局变量或嵌入到设备结构体中

#### 步骤2：初始化定时器
- 使用 `timer_setup()` 初始化定时器并绑定回调函数
- 设置定时器的回调函数和私有数据

#### 步骤3：设置超时时间
- 设置 `timer.expires` 为超时时刻（jiffies + 延时）
- 通常使用 `jiffies + msecs_to_jiffies(ms)` 计算

#### 步骤4：启动定时器
- 使用 `add_timer()` 将定时器添加到内核
- 或使用 `mod_timer()` 修改并启动定时器

#### 步骤5：实现回调函数
- 回调函数运行在软中断上下文
- 不能调用可能睡眠的函数
- 如需周期执行，在回调中重新启动定时器

#### 步骤6：删除定时器
- 模块卸载时使用 `del_timer()` 或 `del_timer_sync()` 删除定时器
- `del_timer_sync()` 会等待回调函数执行完成

### 1.4 高精度定时器使用步骤

#### 步骤1：定义高精度定时器
- 使用 `struct hrtimer` 定义定时器

#### 步骤2：初始化高精度定时器
- 使用 `hrtimer_init()` 初始化
- 指定时钟类型和模式

#### 步骤3：设置回调函数
- 直接赋值 `timer.function = callback`

#### 步骤4：启动高精度定时器
- 使用 `hrtimer_start()` 启动定时器
- 使用 `ktime_set()` 或 `ns_to_ktime()` 设置时间

#### 步骤5：取消高精度定时器
- 使用 `hrtimer_cancel()` 取消定时器

### 1.5 定时器开发流程图

```
[定义timer_list结构体]
         ↓
[timer_setup()初始化]
         ↓
[设置expires超时时间]
         ↓
[add_timer()启动定时器]
         ↓
[定时器运行中] ←───────┐
         ↓              │
[超时触发回调函数]       │
         ↓              │
[周期定时?] ──是──→ [mod_timer()重启]
         │
        否
         ↓
[del_timer_sync()删除]
         ↓
[模块卸载完成]
```

### 1.6 定时器使用注意事项

1. **中断上下文**：回调函数运行在软中断上下文，不能睡眠
2. **不能使用的函数**：`msleep()`、`kmalloc(GFP_KERNEL)`、`mutex_lock()` 等
3. **可以使用的函数**：`udelay()`、`kmalloc(GFP_ATOMIC)`、`spin_lock()` 等
4. **一次性定时器**：默认只执行一次，需周期执行要在回调中重启
5. **同步删除**：卸载模块时建议使用 `del_timer_sync()` 确保回调完成

---

## 第二章 常用变量、结构体与函数详解

### 2.1 时间相关变量

#### jiffies - 系统节拍计数器
```c
extern unsigned long volatile jiffies;
```
- **功能**：记录系统启动以来的节拍数
- **说明**：32位系统使用jiffies，64位系统使用jiffies_64
- **使用场景**：计算定时器超时时间、测量时间间隔

#### HZ - 每秒节拍数
```c
#define HZ 100  /* 或250、1000，取决于内核配置 */
```
- **功能**：定义每秒钟的节拍数
- **说明**：HZ值越大精度越高，但开销也越大
- **查看方法**：`grep CONFIG_HZ /boot/config-$(uname -r)`

### 2.2 低精度定时器结构体

#### struct timer_list - 定时器结构体
```c
struct timer_list {
    struct hlist_node entry;        /* 内部链表节点 */
    unsigned long expires;          /* 超时时间（jiffies） */
    void (*function)(struct timer_list *);  /* 回调函数 */
    u32 flags;                      /* 标志位 */
};
```
- **功能**：描述一个内核定时器
- **关键成员**：
  - `expires`：定时器到期时间，单位为jiffies
  - `function`：超时后执行的回调函数

### 2.3 低精度定时器函数

#### timer_setup() - 初始化定时器
```c
void timer_setup(struct timer_list *timer,
                 void (*callback)(struct timer_list *),
                 unsigned int flags);
```
- **功能**：初始化定时器并设置回调函数
- **参数**：
  - `timer`：定时器结构体指针
  - `callback`：回调函数指针
  - `flags`：标志位，通常为0
- **说明**：替代了旧版的 `init_timer()` 和 `setup_timer()`

#### add_timer() - 启动定时器
```c
void add_timer(struct timer_list *timer);
```
- **功能**：将定时器添加到内核定时器链表，启动定时器
- **参数**：
  - `timer`：已初始化的定时器指针
- **前提**：必须先设置 `timer->expires`

#### mod_timer() - 修改并启动定时器
```c
int mod_timer(struct timer_list *timer, unsigned long expires);
```
- **功能**：修改定时器超时时间，如果定时器未激活则激活它
- **参数**：
  - `timer`：定时器指针
  - `expires`：新的超时时间（jiffies）
- **返回值**：
  - `0`：定时器之前未激活
  - `1`：定时器之前已激活
- **推荐使用**：比 `add_timer()` 更安全、更常用

#### del_timer() - 删除定时器
```c
int del_timer(struct timer_list *timer);
```
- **功能**：从内核定时器链表中删除定时器
- **参数**：
  - `timer`：定时器指针
- **返回值**：
  - `0`：定时器未激活
  - `1`：定时器已激活并被删除
- **注意**：不保证回调函数已执行完成

#### del_timer_sync() - 同步删除定时器
```c
int del_timer_sync(struct timer_list *timer);
```
- **功能**：删除定时器并等待回调函数执行完成
- **参数**：
  - `timer`：定时器指针
- **返回值**：与 `del_timer()` 相同
- **推荐使用**：模块卸载时使用，确保回调完成
- **注意**：不能在中断上下文中调用

#### timer_pending() - 检查定时器是否激活
```c
int timer_pending(const struct timer_list *timer);
```
- **功能**：检查定时器是否在等待队列中
- **参数**：
  - `timer`：定时器指针
- **返回值**：
  - `0`：定时器未激活
  - `非0`：定时器已激活

### 2.4 时间转换函数

#### msecs_to_jiffies() - 毫秒转jiffies
```c
unsigned long msecs_to_jiffies(const unsigned int m);
```
- **功能**：将毫秒转换为jiffies
- **参数**：
  - `m`：毫秒数
- **返回值**：对应的jiffies值
- **常用**：设置定时器超时时间

#### usecs_to_jiffies() - 微秒转jiffies
```c
unsigned long usecs_to_jiffies(const unsigned int u);
```
- **功能**：将微秒转换为jiffies
- **参数**：
  - `u`：微秒数
- **返回值**：对应的jiffies值

#### jiffies_to_msecs() - jiffies转毫秒
```c
unsigned int jiffies_to_msecs(const unsigned long j);
```
- **功能**：将jiffies转换为毫秒
- **参数**：
  - `j`：jiffies值
- **返回值**：对应的毫秒数

#### jiffies_to_usecs() - jiffies转微秒
```c
unsigned int jiffies_to_usecs(const unsigned long j);
```
- **功能**：将jiffies转换为微秒
- **参数**：
  - `j`：jiffies值
- **返回值**：对应的微秒数

### 2.5 时间比较宏

#### time_after() - 判断时间a是否在b之后
```c
#define time_after(a, b)  ((long)(b) - (long)(a) < 0)
```
- **功能**：判断时间a是否晚于时间b
- **说明**：正确处理jiffies回绕问题

#### time_before() - 判断时间a是否在b之前
```c
#define time_before(a, b) time_after(b, a)
```
- **功能**：判断时间a是否早于时间b

#### time_after_eq() - 判断时间a是否不早于b
```c
#define time_after_eq(a, b) ((long)(a) - (long)(b) >= 0)
```
- **功能**：判断时间a是否晚于或等于时间b

#### time_before_eq() - 判断时间a是否不晚于b
```c
#define time_before_eq(a, b) time_after_eq(b, a)
```
- **功能**：判断时间a是否早于或等于时间b

### 2.6 高精度定时器结构体

#### struct hrtimer - 高精度定时器结构体
```c
struct hrtimer {
    struct timerqueue_node node;
    ktime_t _softexpires;
    enum hrtimer_restart (*function)(struct hrtimer *);
    struct hrtimer_clock_base *base;
    u8 state;
    u8 is_rel;
    u8 is_soft;
    u8 is_hard;
};
```
- **功能**：描述一个高精度定时器
- **关键成员**：
  - `function`：回调函数，返回 `HRTIMER_RESTART` 或 `HRTIMER_NORESTART`

#### ktime_t - 高精度时间类型
```c
typedef s64 ktime_t;
```
- **功能**：表示纳秒级时间
- **说明**：用于高精度定时器的时间表示

### 2.7 高精度定时器函数

#### hrtimer_init() - 初始化高精度定时器
```c
void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
                  enum hrtimer_mode mode);
```
- **功能**：初始化高精度定时器
- **参数**：
  - `timer`：高精度定时器指针
  - `clock_id`：时钟类型
    - `CLOCK_MONOTONIC`：单调递增时钟（推荐）
    - `CLOCK_REALTIME`：实时时钟
  - `mode`：定时模式
    - `HRTIMER_MODE_REL`：相对时间
    - `HRTIMER_MODE_ABS`：绝对时间

#### hrtimer_start() - 启动高精度定时器
```c
void hrtimer_start(struct hrtimer *timer, ktime_t tim,
                   const enum hrtimer_mode mode);
```
- **功能**：启动高精度定时器
- **参数**：
  - `timer`：定时器指针
  - `tim`：超时时间（ktime_t）
  - `mode`：定时模式

#### hrtimer_cancel() - 取消高精度定时器
```c
int hrtimer_cancel(struct hrtimer *timer);
```
- **功能**：取消高精度定时器
- **参数**：
  - `timer`：定时器指针
- **返回值**：
  - `0`：定时器未激活
  - `1`：定时器已激活并被取消

#### hrtimer_forward_now() - 重新设置定时器
```c
u64 hrtimer_forward_now(struct hrtimer *timer, ktime_t interval);
```
- **功能**：从当前时间开始重新设置定时器
- **参数**：
  - `timer`：定时器指针
  - `interval`：时间间隔
- **使用场景**：在回调中实现周期定时

#### ktime_set() - 创建ktime时间
```c
ktime_t ktime_set(const s64 secs, const unsigned long nsecs);
```
- **功能**：根据秒和纳秒创建ktime_t时间
- **参数**：
  - `secs`：秒数
  - `nsecs`：纳秒数
- **返回值**：ktime_t时间值

#### ns_to_ktime() - 纳秒转ktime
```c
ktime_t ns_to_ktime(u64 ns);
```
- **功能**：将纳秒转换为ktime_t
- **参数**：
  - `ns`：纳秒数

#### ms_to_ktime() - 毫秒转ktime
```c
ktime_t ms_to_ktime(u64 ms);
```
- **功能**：将毫秒转换为ktime_t
- **参数**：
  - `ms`：毫秒数

### 2.8 延时函数

#### mdelay() - 毫秒级忙等待
```c
void mdelay(unsigned long msecs);
```
- **功能**：毫秒级忙等待延时
- **参数**：
  - `msecs`：延时毫秒数
- **注意**：忙等待，占用CPU，不推荐长时间使用

#### udelay() - 微秒级忙等待
```c
void udelay(unsigned long usecs);
```
- **功能**：微秒级忙等待延时
- **参数**：
  - `usecs`：延时微秒数
- **限制**：通常不超过1ms

#### ndelay() - 纳秒级忙等待
```c
void ndelay(unsigned long nsecs);
```
- **功能**：纳秒级忙等待延时
- **参数**：
  - `nsecs`：延时纳秒数

#### msleep() - 毫秒级睡眠
```c
void msleep(unsigned int msecs);
```
- **功能**：毫秒级睡眠延时
- **参数**：
  - `msecs`：延时毫秒数
- **注意**：会让出CPU，不能在中断上下文使用

#### usleep_range() - 微秒级睡眠
```c
void usleep_range(unsigned long min, unsigned long max);
```
- **功能**：微秒级睡眠延时，指定范围
- **参数**：
  - `min`：最小延时微秒数
  - `max`：最大延时微秒数
- **推荐使用**：比usleep更精确

#### ssleep() - 秒级睡眠
```c
void ssleep(unsigned int seconds);
```
- **功能**：秒级睡眠延时
- **参数**：
  - `seconds`：延时秒数

---

## 第三章 完整示例代码

### 3.1 低精度定时器驱动（timer_dev.c）

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/timer.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define DEVICE_NAME "timer_dev"
#define DEVICE_COUNT 1

/* 设备结构体 */
struct timer_device {
    struct cdev cdev;
    dev_t devno;
    struct class *class;
    struct device *device;
    
    struct timer_list timer;        /* 定时器 */
    unsigned long period_ms;        /* 定时周期（毫秒） */
    unsigned long trigger_count;    /* 触发次数 */
    bool timer_running;             /* 定时器运行标志 */
};

static struct timer_device *tdev;

/* ==================== 定时器回调函数 ==================== */
static void timer_callback(struct timer_list *t)
{
    struct timer_device *dev = from_timer(dev, t, timer);
    
    dev->trigger_count++;
    printk(KERN_INFO "timer_dev: Timer triggered! Count=%lu\n", 
           dev->trigger_count);
    
    /* 如果定时器仍在运行，重新启动（周期定时） */
    if (dev->timer_running) {
        mod_timer(&dev->timer, jiffies + msecs_to_jiffies(dev->period_ms));
    }
}

/* ==================== open 函数 ==================== */
static int timer_open(struct inode *inode, struct file *filp)
{
    struct timer_device *dev;
    
    dev = container_of(inode->i_cdev, struct timer_device, cdev);
    filp->private_data = dev;
    
    printk(KERN_INFO "timer_dev: Device opened\n");
    return 0;
}

/* ==================== release 函数 ==================== */
static int timer_release(struct inode *inode, struct file *filp)
{
    printk(KERN_INFO "timer_dev: Device closed\n");
    return 0;
}

/* ==================== read 函数 - 读取触发次数 ==================== */
static ssize_t timer_read(struct file *filp, char __user *buf,
                          size_t count, loff_t *f_pos)
{
    struct timer_device *dev = filp->private_data;
    char kbuf[64];
    int len;
    
    if (*f_pos > 0)
        return 0;
    
    len = snprintf(kbuf, sizeof(kbuf), "Timer count: %lu, Running: %s\n",
                   dev->trigger_count, 
                   dev->timer_running ? "yes" : "no");
    
    if (count < len)
        len = count;
    
    if (copy_to_user(buf, kbuf, len))
        return -EFAULT;
    
    *f_pos += len;
    return len;
}

/* ==================== write 函数 - 控制定时器 ==================== */
static ssize_t timer_write(struct file *filp, const char __user *buf,
                           size_t count, loff_t *f_pos)
{
    struct timer_device *dev = filp->private_data;
    char kbuf[32];
    unsigned long period;
    
    if (count >= sizeof(kbuf))
        return -EINVAL;
    
    if (copy_from_user(kbuf, buf, count))
        return -EFAULT;
    
    kbuf[count] = '\0';
    
    /* 命令解析 */
    if (strncmp(kbuf, "start", 5) == 0) {
        /* 启动定时器，默认1000ms */
        if (!dev->timer_running) {
            dev->period_ms = 1000;
            dev->timer_running = true;
            mod_timer(&dev->timer, 
                      jiffies + msecs_to_jiffies(dev->period_ms));
            printk(KERN_INFO "timer_dev: Timer started, period=%lums\n", 
                   dev->period_ms);
        }
    } else if (strncmp(kbuf, "stop", 4) == 0) {
        /* 停止定时器 */
        dev->timer_running = false;
        del_timer_sync(&dev->timer);
        printk(KERN_INFO "timer_dev: Timer stopped\n");
    } else if (strncmp(kbuf, "period=", 7) == 0) {
        /* 设置周期 */
        if (kstrtoul(kbuf + 7, 10, &period) == 0 && period > 0) {
            dev->period_ms = period;
            if (dev->timer_running) {
                mod_timer(&dev->timer, 
                          jiffies + msecs_to_jiffies(dev->period_ms));
            }
            printk(KERN_INFO "timer_dev: Period set to %lums\n", period);
        }
    } else if (strncmp(kbuf, "reset", 5) == 0) {
        /* 重置计数 */
        dev->trigger_count = 0;
        printk(KERN_INFO "timer_dev: Counter reset\n");
    }
    
    return count;
}

/* ==================== 文件操作结构体 ==================== */
static struct file_operations timer_fops = {
    .owner = THIS_MODULE,
    .open = timer_open,
    .release = timer_release,
    .read = timer_read,
    .write = timer_write,
};

/* ==================== 模块初始化 ==================== */
static int __init timer_dev_init(void)
{
    int ret;
    
    printk(KERN_INFO "timer_dev: Initializing module, HZ=%d\n", HZ);
    
    /* 分配设备结构体 */
    tdev = kzalloc(sizeof(struct timer_device), GFP_KERNEL);
    if (!tdev)
        return -ENOMEM;
    
    /* 初始化定时器 */
    timer_setup(&tdev->timer, timer_callback, 0);
    tdev->period_ms = 1000;
    tdev->trigger_count = 0;
    tdev->timer_running = false;
    
    /* 分配设备号 */
    ret = alloc_chrdev_region(&tdev->devno, 0, DEVICE_COUNT, DEVICE_NAME);
    if (ret < 0) {
        printk(KERN_ERR "timer_dev: Failed to allocate device number\n");
        goto fail_alloc;
    }
    
    /* 初始化并注册字符设备 */
    cdev_init(&tdev->cdev, &timer_fops);
    tdev->cdev.owner = THIS_MODULE;
    ret = cdev_add(&tdev->cdev, tdev->devno, DEVICE_COUNT);
    if (ret < 0) {
        printk(KERN_ERR "timer_dev: Failed to add cdev\n");
        goto fail_cdev;
    }
    
    /* 创建设备类 */
    tdev->class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(tdev->class)) {
        ret = PTR_ERR(tdev->class);
        goto fail_class;
    }
    
    /* 创建设备节点 */
    tdev->device = device_create(tdev->class, NULL, tdev->devno, 
                                  NULL, DEVICE_NAME);
    if (IS_ERR(tdev->device)) {
        ret = PTR_ERR(tdev->device);
        goto fail_device;
    }
    
    printk(KERN_INFO "timer_dev: Device created at /dev/%s\n", DEVICE_NAME);
    return 0;

fail_device:
    class_destroy(tdev->class);
fail_class:
    cdev_del(&tdev->cdev);
fail_cdev:
    unregister_chrdev_region(tdev->devno, DEVICE_COUNT);
fail_alloc:
    kfree(tdev);
    return ret;
}

/* ==================== 模块退出 ==================== */
static void __exit timer_dev_exit(void)
{
    printk(KERN_INFO "timer_dev: Exiting module\n");
    
    /* 停止并删除定时器 */
    tdev->timer_running = false;
    del_timer_sync(&tdev->timer);
    
    /* 清理设备 */
    device_destroy(tdev->class, tdev->devno);
    class_destroy(tdev->class);
    cdev_del(&tdev->cdev);
    unregister_chrdev_region(tdev->devno, DEVICE_COUNT);
    kfree(tdev);
    
    printk(KERN_INFO "timer_dev: Module exited\n");
}

module_init(timer_dev_init);
module_exit(timer_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Linux Timer Example Driver");
MODULE_VERSION("1.0");
```

### 3.2 高精度定时器驱动（hrtimer_dev.c）

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/hrtimer.h>
#include <linux/ktime.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define DEVICE_NAME "hrtimer_dev"
#define DEVICE_COUNT 1
#define DEFAULT_PERIOD_NS 1000000000ULL  /* 默认1秒 = 1000000000纳秒 */

/* 设备结构体 */
struct hrtimer_device {
    struct cdev cdev;
    dev_t devno;
    struct class *class;
    struct device *device;
    
    struct hrtimer hr_timer;        /* 高精度定时器 */
    ktime_t period;                 /* 定时周期 */
    unsigned long trigger_count;    /* 触发次数 */
    bool timer_running;             /* 定时器运行标志 */
};

static struct hrtimer_device *hrdev;

/* ==================== 高精度定时器回调函数 ==================== */
static enum hrtimer_restart hrtimer_callback(struct hrtimer *timer)
{
    struct hrtimer_device *dev = container_of(timer, 
                                               struct hrtimer_device, 
                                               hr_timer);
    
    dev->trigger_count++;
    printk(KERN_INFO "hrtimer_dev: HR Timer triggered! Count=%lu\n", 
           dev->trigger_count);
    
    /* 周期定时：重新设置定时器 */
    if (dev->timer_running) {
        hrtimer_forward_now(timer, dev->period);
        return HRTIMER_RESTART;  /* 重启定时器 */
    }
    
    return HRTIMER_NORESTART;  /* 不重启 */
}

/* ==================== open 函数 ==================== */
static int hrtimer_open(struct inode *inode, struct file *filp)
{
    struct hrtimer_device *dev;
    
    dev = container_of(inode->i_cdev, struct hrtimer_device, cdev);
    filp->private_data = dev;
    
    printk(KERN_INFO "hrtimer_dev: Device opened\n");
    return 0;
}

/* ==================== release 函数 ==================== */
static int hrtimer_release(struct inode *inode, struct file *filp)
{
    printk(KERN_INFO "hrtimer_dev: Device closed\n");
    return 0;
}

/* ==================== read 函数 ==================== */
static ssize_t hrtimer_read(struct file *filp, char __user *buf,
                            size_t count, loff_t *f_pos)
{
    struct hrtimer_device *dev = filp->private_data;
    char kbuf[128];
    int len;
    s64 period_ns = ktime_to_ns(dev->period);
    
    if (*f_pos > 0)
        return 0;
    
    len = snprintf(kbuf, sizeof(kbuf), 
                   "HR Timer count: %lu\nPeriod: %lld ns (%lld ms)\nRunning: %s\n",
                   dev->trigger_count,
                   period_ns, period_ns / 1000000,
                   dev->timer_running ? "yes" : "no");
    
    if (count < len)
        len = count;
    
    if (copy_to_user(buf, kbuf, len))
        return -EFAULT;
    
    *f_pos += len;
    return len;
}

/* ==================== write 函数 ==================== */
static ssize_t hrtimer_write(struct file *filp, const char __user *buf,
                             size_t count, loff_t *f_pos)
{
    struct hrtimer_device *dev = filp->private_data;
    char kbuf[32];
    unsigned long period_ms;
    
    if (count >= sizeof(kbuf))
        return -EINVAL;
    
    if (copy_from_user(kbuf, buf, count))
        return -EFAULT;
    
    kbuf[count] = '\0';
    
    /* 命令解析 */
    if (strncmp(kbuf, "start", 5) == 0) {
        if (!dev->timer_running) {
            dev->timer_running = true;
            hrtimer_start(&dev->hr_timer, dev->period, HRTIMER_MODE_REL);
            printk(KERN_INFO "hrtimer_dev: HR Timer started\n");
        }
    } else if (strncmp(kbuf, "stop", 4) == 0) {
        dev->timer_running = false;
        hrtimer_cancel(&dev->hr_timer);
        printk(KERN_INFO "hrtimer_dev: HR Timer stopped\n");
    } else if (strncmp(kbuf, "period_ms=", 10) == 0) {
        /* 设置周期（毫秒） */
        if (kstrtoul(kbuf + 10, 10, &period_ms) == 0 && period_ms > 0) {
            dev->period = ms_to_ktime(period_ms);
            printk(KERN_INFO "hrtimer_dev: Period set to %lums\n", period_ms);
        }
    } else if (strncmp(kbuf, "reset", 5) == 0) {
        dev->trigger_count = 0;
        printk(KERN_INFO "hrtimer_dev: Counter reset\n");
    }
    
    return count;
}

/* ==================== 文件操作结构体 ==================== */
static struct file_operations hrtimer_fops = {
    .owner = THIS_MODULE,
    .open = hrtimer_open,
    .release = hrtimer_release,
    .read = hrtimer_read,
    .write = hrtimer_write,
};

/* ==================== 模块初始化 ==================== */
static int __init hrtimer_dev_init(void)
{
    int ret;
    
    printk(KERN_INFO "hrtimer_dev: Initializing module\n");
    
    /* 分配设备结构体 */
    hrdev = kzalloc(sizeof(struct hrtimer_device), GFP_KERNEL);
    if (!hrdev)
        return -ENOMEM;
    
    /* 初始化高精度定时器 */
    hrtimer_init(&hrdev->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
    hrdev->hr_timer.function = hrtimer_callback;
    hrdev->period = ns_to_ktime(DEFAULT_PERIOD_NS);
    hrdev->trigger_count = 0;
    hrdev->timer_running = false;
    
    /* 分配设备号 */
    ret = alloc_chrdev_region(&hrdev->devno, 0, DEVICE_COUNT, DEVICE_NAME);
    if (ret < 0) {
        printk(KERN_ERR "hrtimer_dev: Failed to allocate device number\n");
        goto fail_alloc;
    }
    
    /* 初始化并注册字符设备 */
    cdev_init(&hrdev->cdev, &hrtimer_fops);
    hrdev->cdev.owner = THIS_MODULE;
    ret = cdev_add(&hrdev->cdev, hrdev->devno, DEVICE_COUNT);
    if (ret < 0) {
        printk(KERN_ERR "hrtimer_dev: Failed to add cdev\n");
        goto fail_cdev;
    }
    
    /* 创建设备类 */
    hrdev->class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(hrdev->class)) {
        ret = PTR_ERR(hrdev->class);
        goto fail_class;
    }
    
    /* 创建设备节点 */
    hrdev->device = device_create(hrdev->class, NULL, hrdev->devno, 
                                   NULL, DEVICE_NAME);
    if (IS_ERR(hrdev->device)) {
        ret = PTR_ERR(hrdev->device);
        goto fail_device;
    }
    
    printk(KERN_INFO "hrtimer_dev: Device created at /dev/%s\n", DEVICE_NAME);
    return 0;

fail_device:
    class_destroy(hrdev->class);
fail_class:
    cdev_del(&hrdev->cdev);
fail_cdev:
    unregister_chrdev_region(hrdev->devno, DEVICE_COUNT);
fail_alloc:
    kfree(hrdev);
    return ret;
}

/* ==================== 模块退出 ==================== */
static void __exit hrtimer_dev_exit(void)
{
    printk(KERN_INFO "hrtimer_dev: Exiting module\n");
    
    /* 取消高精度定时器 */
    hrdev->timer_running = false;
    hrtimer_cancel(&hrdev->hr_timer);
    
    /* 清理设备 */
    device_destroy(hrdev->class, hrdev->devno);
    class_destroy(hrdev->class);
    cdev_del(&hrdev->cdev);
    unregister_chrdev_region(hrdev->devno, DEVICE_COUNT);
    kfree(hrdev);
    
    printk(KERN_INFO "hrtimer_dev: Module exited\n");
}

module_init(hrtimer_dev_init);
module_exit(hrtimer_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Linux High Resolution Timer Example Driver");
MODULE_VERSION("1.0");
```

### 3.3 Makefile

```makefile
obj-m := timer_dev.o hrtimer_dev.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```

### 3.4 测试程序（test_timer.c）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void test_timer(const char *device_path)
{
    int fd;
    char buf[256];
    ssize_t ret;
    
    printf("=== 测试设备: %s ===\n\n", device_path);
    
    /* 打开设备 */
    fd = open(device_path, O_RDWR);
    if (fd < 0) {
        perror("open");
        return;
    }
    
    /* 读取初始状态 */
    printf("[1] 初始状态:\n");
    ret = read(fd, buf, sizeof(buf) - 1);
    if (ret > 0) {
        buf[ret] = '\0';
        printf("%s\n", buf);
    }
    lseek(fd, 0, SEEK_SET);
    
    /* 设置周期为500ms */
    printf("[2] 设置周期为500ms\n");
    write(fd, "period=500", 10);
    sleep(1);
    
    /* 启动定时器 */
    printf("[3] 启动定时器，等待3秒...\n");
    write(fd, "start", 5);
    sleep(3);
    
    /* 读取状态 */
    printf("[4] 当前状态:\n");
    ret = read(fd, buf, sizeof(buf) - 1);
    if (ret > 0) {
        buf[ret] = '\0';
        printf("%s\n", buf);
    }
    lseek(fd, 0, SEEK_SET);
    
    /* 停止定时器 */
    printf("[5] 停止定时器\n");
    write(fd, "stop", 4);
    
    /* 读取最终状态 */
    printf("[6] 最终状态:\n");
    ret = read(fd, buf, sizeof(buf) - 1);
    if (ret > 0) {
        buf[ret] = '\0';
        printf("%s\n", buf);
    }
    
    /* 重置计数 */
    write(fd, "reset", 5);
    printf("[7] 计数已重置\n");
    
    close(fd);
    printf("=== 测试完成 ===\n\n");
}

int main()
{
    printf("Linux Timer Driver Test\n");
    printf("========================\n\n");
    
    /* 测试低精度定时器 */
    test_timer("/dev/timer_dev");
    
    /* 测试高精度定时器 */
    test_timer("/dev/hrtimer_dev");
    
    return 0;
}
```

### 3.5 测试脚本（test.sh）

```bash
#!/bin/bash

echo "=== Linux 定时器驱动测试 ==="
echo ""

# 编译驱动
echo "[1] 编译内核模块..."
make clean && make
if [ $? -ne 0 ]; then
    echo "错误：模块编译失败"
    exit 1
fi
echo "✓ 模块编译成功"
echo ""

# 加载低精度定时器模块
echo "[2] 加载低精度定时器模块..."
sudo insmod timer_dev.ko
if [ $? -ne 0 ]; then
    echo "错误：timer_dev模块加载失败"
    exit 1
fi
echo "✓ timer_dev模块加载成功"

# 加载高精度定时器模块
echo "[3] 加载高精度定时器模块..."
sudo insmod hrtimer_dev.ko
if [ $? -ne 0 ]; then
    echo "错误：hrtimer_dev模块加载失败"
    sudo rmmod timer_dev
    exit 1
fi
echo "✓ hrtimer_dev模块加载成功"
echo ""

# 设置权限
echo "[4] 设置设备权限..."
sudo chmod 666 /dev/timer_dev
sudo chmod 666 /dev/hrtimer_dev
ls -l /dev/timer_dev /dev/hrtimer_dev
echo ""

# 编译测试程序
echo "[5] 编译测试程序..."
gcc -o test_timer test_timer.c
echo "✓ 测试程序编译完成"
echo ""

# 手动测试
echo "[6] 手动测试低精度定时器..."
echo "start" > /dev/timer_dev
sleep 2
cat /dev/timer_dev
echo "stop" > /dev/timer_dev
echo ""

# 运行测试程序
echo "[7] 运行测试程序..."
./test_timer
echo ""

# 查看内核日志
echo "[8] 内核日志："
dmesg | tail -30 | grep -E "timer_dev|hrtimer_dev"
echo ""

# 清理
echo "[9] 清理..."
read -p "按Enter键卸载模块并清理..."
sudo rmmod hrtimer_dev
sudo rmmod timer_dev
make clean
rm -f test_timer
echo "✓ 清理完成"
```

### 3.6 使用说明

#### 编译与加载
```bash
# 编译驱动
make

# 加载驱动
sudo insmod timer_dev.ko      # 低精度定时器
sudo insmod hrtimer_dev.ko    # 高精度定时器

# 设置权限
sudo chmod 666 /dev/timer_dev
sudo chmod 666 /dev/hrtimer_dev
```

#### 控制定时器
```bash
# 启动定时器
echo "start" > /dev/timer_dev

# 停止定时器
echo "stop" > /dev/timer_dev

# 设置周期（低精度，单位：毫秒）
echo "period=500" > /dev/timer_dev

# 设置周期（高精度，单位：毫秒）
echo "period_ms=100" > /dev/hrtimer_dev

# 重置计数
echo "reset" > /dev/timer_dev

# 读取状态
cat /dev/timer_dev
```

#### 查看日志
```bash
# 查看定时器触发日志
dmesg | grep timer_dev

# 实时监控
sudo dmesg -w | grep timer
```

#### 卸载驱动
```bash
sudo rmmod hrtimer_dev
sudo rmmod timer_dev
```

---

## 附录：定时器类型对比

| 特性 | 低精度定时器 | 高精度定时器 |
|------|-------------|-------------|
| 结构体 | `struct timer_list` | `struct hrtimer` |
| 时间单位 | jiffies | ktime_t (纳秒) |
| 精度 | 毫秒级 (1000/HZ ms) | 纳秒级 |
| 初始化 | `timer_setup()` | `hrtimer_init()` |
| 启动 | `add_timer()` / `mod_timer()` | `hrtimer_start()` |
| 删除 | `del_timer_sync()` | `hrtimer_cancel()` |
| 周期定时 | 回调中调用 `mod_timer()` | 返回 `HRTIMER_RESTART` |
| 适用场景 | 一般延时任务 | 精确定时需求 |

## 附录：延时函数对比

| 函数 | 精度 | 是否睡眠 | 可用上下文 |
|------|------|----------|-----------|
| `ndelay()` | 纳秒 | 否（忙等待） | 任意 |
| `udelay()` | 微秒 | 否（忙等待） | 任意 |
| `mdelay()` | 毫秒 | 否（忙等待） | 任意 |
| `usleep_range()` | 微秒 | 是 | 进程上下文 |
| `msleep()` | 毫秒 | 是 | 进程上下文 |
| `ssleep()` | 秒 | 是 | 进程上下文 |
