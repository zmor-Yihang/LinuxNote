# Linux驱动开发IO模型总结

## 第一章 IO模型开发步骤

### 1.1 IO模型概述

Linux提供了五种IO模型，用于处理用户空间与内核空间之间的数据交互：

| IO模型 | 特点 | 适用场景 |
|--------|------|----------|
| 阻塞IO | 进程等待数据就绪，期间被挂起 | 简单应用，单一设备操作 |
| 非阻塞IO | 立即返回，需要轮询检查数据状态 | 需要同时处理其他任务 |
| IO多路复用 | 同时监控多个文件描述符 | 多设备并发处理 |
| 信号驱动IO | 数据就绪时内核发送信号通知 | 异步通知场景 |
| 异步IO | 完全异步，内核完成后通知进程 | 高性能服务器 |

### 1.2 阻塞IO实现步骤

#### 步骤1：定义并初始化等待队列头
- 使用 `wait_queue_head_t` 定义等待队列头
- 使用 `init_waitqueue_head()` 初始化等待队列

#### 步骤2：定义条件标志
- 定义用于判断是否唤醒进程的条件变量
- 条件满足时设置为真，不满足时设置为假

#### 步骤3：在读/写函数中等待条件满足
- 使用 `wait_event_interruptible()` 使进程进入睡眠
- 条件满足时进程被自动唤醒

#### 步骤4：在数据就绪时唤醒等待进程
- 使用 `wake_up_interruptible()` 唤醒等待队列中的进程
- 通常在中断处理或数据准备完成后调用

### 1.3 非阻塞IO实现步骤

#### 步骤1：检查文件打开标志
- 检查 `filp->f_flags & O_NONBLOCK` 判断是否非阻塞模式

#### 步骤2：数据未就绪时立即返回
- 非阻塞模式下，数据未就绪返回 `-EAGAIN`
- 阻塞模式下，调用等待队列进入睡眠

#### 步骤3：用户空间配合
- 用户空间使用 `O_NONBLOCK` 标志打开设备
- 循环检查返回值进行轮询

### 1.4 IO多路复用实现步骤（poll机制）

#### 步骤1：实现驱动的poll函数
- 在 `file_operations` 中注册 `.poll` 回调函数

#### 步骤2：调用poll_wait注册等待队列
- 使用 `poll_wait()` 将等待队列添加到poll表
- 不会使进程立即睡眠

#### 步骤3：返回设备状态掩码
- 返回 `POLLIN | POLLRDNORM` 表示可读
- 返回 `POLLOUT | POLLWRNORM` 表示可写

#### 步骤4：用户空间使用select/poll/epoll
- 调用 `select()`、`poll()` 或 `epoll()` 监控多个设备

### 1.5 信号驱动IO实现步骤（异步通知）

#### 步骤1：定义fasync_struct指针
- 在设备结构体中添加 `struct fasync_struct *async_queue`

#### 步骤2：实现fasync函数
- 在 `file_operations` 中注册 `.fasync` 回调
- 调用 `fasync_helper()` 初始化异步通知队列

#### 步骤3：在release中清理异步通知
- 调用 `fasync_helper()` 传入 `-1` 清理

#### 步骤4：数据就绪时发送信号
- 使用 `kill_fasync()` 向用户进程发送 `SIGIO` 信号

#### 步骤5：用户空间设置信号处理
- 设置 `SIGIO` 信号处理函数
- 使用 `fcntl()` 设置文件描述符的异步通知

### 1.6 IO模型开发流程图

```
[用户发起IO请求]
        ↓
[检查f_flags标志] ──非阻塞──→ [数据未就绪?] ──是──→ [返回-EAGAIN]
        │                           │
      阻塞                          否
        ↓                           ↓
[wait_event等待]              [处理数据]
        ↓                           ↓
[中断/事件触发]               [返回成功]
        ↓
[wake_up唤醒]
        ↓
[处理数据并返回]
```

---

## 第二章 常用变量、结构体与函数详解

### 2.1 等待队列相关

#### wait_queue_head_t - 等待队列头结构体
```c
wait_queue_head_t my_queue;
```
- **功能**：定义等待队列头，用于管理睡眠的进程
- **说明**：每个等待队列需要一个队列头来组织

#### DECLARE_WAIT_QUEUE_HEAD() - 静态定义并初始化等待队列头
```c
DECLARE_WAIT_QUEUE_HEAD(name);
```
- **功能**：静态定义并初始化等待队列头
- **参数**：
  - `name`：等待队列头变量名
- **使用场景**：全局或静态等待队列

#### init_waitqueue_head() - 动态初始化等待队列头
```c
void init_waitqueue_head(wait_queue_head_t *q);
```
- **功能**：动态初始化等待队列头
- **参数**：
  - `q`：等待队列头指针
- **使用场景**：结构体成员或动态分配的等待队列

#### wait_event() - 无条件等待（不可中断）
```c
wait_event(wq, condition);
```
- **功能**：使进程进入不可中断的睡眠状态，直到条件为真
- **参数**：
  - `wq`：等待队列头
  - `condition`：唤醒条件表达式
- **注意**：不响应信号，慎用

#### wait_event_interruptible() - 可中断等待
```c
int wait_event_interruptible(wait_queue_head_t wq, condition);
```
- **功能**：使进程进入可中断的睡眠状态
- **参数**：
  - `wq`：等待队列头
  - `condition`：唤醒条件表达式
- **返回值**：
  - `0`：条件满足被唤醒
  - `-ERESTARTSYS`：被信号中断
- **推荐使用**：大多数场景的首选

#### wait_event_timeout() - 带超时的等待
```c
long wait_event_timeout(wait_queue_head_t wq, condition, long timeout);
```
- **功能**：等待条件满足或超时
- **参数**：
  - `wq`：等待队列头
  - `condition`：唤醒条件表达式
  - `timeout`：超时时间（jiffies单位）
- **返回值**：
  - `0`：超时
  - `>0`：剩余的jiffies数

#### wait_event_interruptible_timeout() - 可中断的超时等待
```c
long wait_event_interruptible_timeout(wait_queue_head_t wq, condition, long timeout);
```
- **功能**：可中断的超时等待
- **返回值**：
  - `0`：超时
  - `>0`：剩余时间
  - `-ERESTARTSYS`：被信号中断

#### wake_up() - 唤醒所有等待进程
```c
void wake_up(wait_queue_head_t *q);
```
- **功能**：唤醒等待队列中的所有进程
- **参数**：
  - `q`：等待队列头指针

#### wake_up_interruptible() - 唤醒可中断等待的进程
```c
void wake_up_interruptible(wait_queue_head_t *q);
```
- **功能**：唤醒处于可中断睡眠状态的进程
- **参数**：
  - `q`：等待队列头指针
- **配合使用**：与 `wait_event_interruptible()` 配对使用

### 2.2 Poll机制相关

#### poll_table - poll等待表结构
```c
struct poll_table_struct;
typedef struct poll_table_struct poll_table;
```
- **功能**：select/poll/epoll机制使用的等待表结构
- **说明**：由内核自动管理，驱动只需传递使用

#### poll_wait() - 将等待队列添加到poll表
```c
void poll_wait(struct file *filp, wait_queue_head_t *queue, poll_table *wait);
```
- **功能**：将等待队列头添加到poll表中
- **参数**：
  - `filp`：文件指针
  - `queue`：等待队列头指针
  - `wait`：poll表指针
- **注意**：此函数不会导致进程睡眠

#### Poll事件掩码常量
```c
#define POLLIN      0x0001  /* 有数据可读 */
#define POLLPRI     0x0002  /* 有紧急数据可读 */
#define POLLOUT     0x0004  /* 可以写数据 */
#define POLLERR     0x0008  /* 发生错误 */
#define POLLHUP     0x0010  /* 挂起 */
#define POLLNVAL    0x0020  /* 无效的请求 */
#define POLLRDNORM  0x0040  /* 普通数据可读 */
#define POLLRDBAND  0x0080  /* 优先级带数据可读 */
#define POLLWRNORM  0x0100  /* 普通数据可写 */
#define POLLWRBAND  0x0200  /* 优先级带数据可写 */
```

### 2.3 异步通知相关

#### fasync_struct - 异步通知结构体
```c
struct fasync_struct {
    spinlock_t fa_lock;
    int magic;
    int fa_fd;
    struct fasync_struct *fa_next;
    struct file *fa_file;
    struct rcu_head fa_rcu;
};
```
- **功能**：管理异步通知的进程列表
- **使用**：在设备结构体中定义指针成员

#### fasync_helper() - 初始化/清理异步通知
```c
int fasync_helper(int fd, struct file *filp, int on, struct fasync_struct **fapp);
```
- **功能**：添加或删除异步通知
- **参数**：
  - `fd`：文件描述符
  - `filp`：文件指针
  - `on`：开关标志（非0添加，0删除）
  - `fapp`：fasync_struct指针的指针
- **返回值**：成功返回0或正数，失败返回负数错误码

#### kill_fasync() - 发送信号给异步通知进程
```c
void kill_fasync(struct fasync_struct **fp, int sig, int band);
```
- **功能**：向注册了异步通知的进程发送信号
- **参数**：
  - `fp`：fasync_struct指针的指针
  - `sig`：要发送的信号，通常为 `SIGIO`
  - `band`：事件类型
    - `POLL_IN`：可读
    - `POLL_OUT`：可写
    - `POLL_ERR`：错误

### 2.4 文件标志相关

#### O_NONBLOCK - 非阻塞标志
```c
#define O_NONBLOCK  00004000
```
- **功能**：用户空间打开文件时指定非阻塞模式
- **检查方法**：`filp->f_flags & O_NONBLOCK`

#### f_flags - 文件标志成员
```c
struct file {
    // ...
    unsigned int f_flags;  /* 文件打开标志 */
    // ...
};
```
- **功能**：存储文件打开时的标志
- **常用标志**：`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_NONBLOCK`

### 2.5 常用返回错误码

| 错误码 | 值 | 含义 |
|--------|-----|------|
| `-EAGAIN` | -11 | 资源暂时不可用（非阻塞时使用） |
| `-ERESTARTSYS` | -512 | 被信号中断，需要重启系统调用 |
| `-EINTR` | -4 | 操作被中断 |
| `-EFAULT` | -14 | 地址错误 |
| `-EINVAL` | -22 | 无效参数 |

---

## 第三章 完整示例代码

### 3.1 综合IO模型驱动源码（io_model_dev.c）

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/wait.h>
#include <linux/poll.h>
#include <linux/sched/signal.h>

#define DEVICE_NAME "io_model_dev"
#define DEVICE_COUNT 1
#define BUFFER_SIZE 1024

/* 设备结构体 */
struct io_model_device {
    struct cdev cdev;
    dev_t devno;
    struct class *class;
    struct device *device;
    
    char *buffer;                       /* 数据缓冲区 */
    size_t data_len;                    /* 当前数据长度 */
    
    wait_queue_head_t read_queue;       /* 读等待队列 */
    wait_queue_head_t write_queue;      /* 写等待队列 */
    
    struct fasync_struct *async_queue;  /* 异步通知队列 */
    
    struct mutex mutex;                 /* 互斥锁 */
};

static struct io_model_device *iodev;

/* ==================== open 函数 ==================== */
static int iodev_open(struct inode *inode, struct file *filp)
{
    struct io_model_device *dev;
    
    dev = container_of(inode->i_cdev, struct io_model_device, cdev);
    filp->private_data = dev;
    
    printk(KERN_INFO "io_model_dev: Device opened, flags=0x%x\n", filp->f_flags);
    return 0;
}

/* ==================== release 函数 ==================== */
static int iodev_release(struct inode *inode, struct file *filp)
{
    struct io_model_device *dev = filp->private_data;
    
    /* 清理异步通知 */
    if (dev->async_queue)
        fasync_helper(-1, filp, 0, &dev->async_queue);
    
    printk(KERN_INFO "io_model_dev: Device closed\n");
    return 0;
}

/* ==================== read 函数（支持阻塞/非阻塞） ==================== */
static ssize_t iodev_read(struct file *filp, char __user *buf,
                          size_t count, loff_t *f_pos)
{
    struct io_model_device *dev = filp->private_data;
    ssize_t ret;
    
    if (mutex_lock_interruptible(&dev->mutex))
        return -ERESTARTSYS;
    
    /* 数据未就绪时的处理 */
    while (dev->data_len == 0) {
        mutex_unlock(&dev->mutex);
        
        /* 非阻塞模式：立即返回 */
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        printk(KERN_INFO "io_model_dev: Read blocking...\n");
        
        /* 阻塞模式：等待数据就绪 */
        if (wait_event_interruptible(dev->read_queue, dev->data_len > 0))
            return -ERESTARTSYS;  /* 被信号中断 */
        
        if (mutex_lock_interruptible(&dev->mutex))
            return -ERESTARTSYS;
    }
    
    /* 读取数据 */
    if (count > dev->data_len)
        count = dev->data_len;
    
    if (copy_to_user(buf, dev->buffer, count)) {
        mutex_unlock(&dev->mutex);
        return -EFAULT;
    }
    
    /* 移动剩余数据 */
    memmove(dev->buffer, dev->buffer + count, dev->data_len - count);
    dev->data_len -= count;
    ret = count;
    
    mutex_unlock(&dev->mutex);
    
    /* 唤醒写等待队列 */
    wake_up_interruptible(&dev->write_queue);
    
    printk(KERN_INFO "io_model_dev: Read %zd bytes\n", ret);
    return ret;
}

/* ==================== write 函数（支持阻塞/非阻塞） ==================== */
static ssize_t iodev_write(struct file *filp, const char __user *buf,
                           size_t count, loff_t *f_pos)
{
    struct io_model_device *dev = filp->private_data;
    ssize_t ret;
    size_t space_available;
    
    if (mutex_lock_interruptible(&dev->mutex))
        return -ERESTARTSYS;
    
    /* 缓冲区满时的处理 */
    while (dev->data_len >= BUFFER_SIZE) {
        mutex_unlock(&dev->mutex);
        
        /* 非阻塞模式：立即返回 */
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        
        printk(KERN_INFO "io_model_dev: Write blocking...\n");
        
        /* 阻塞模式：等待空间可用 */
        if (wait_event_interruptible(dev->write_queue, 
                                     dev->data_len < BUFFER_SIZE))
            return -ERESTARTSYS;
        
        if (mutex_lock_interruptible(&dev->mutex))
            return -ERESTARTSYS;
    }
    
    /* 写入数据 */
    space_available = BUFFER_SIZE - dev->data_len;
    if (count > space_available)
        count = space_available;
    
    if (copy_from_user(dev->buffer + dev->data_len, buf, count)) {
        mutex_unlock(&dev->mutex);
        return -EFAULT;
    }
    
    dev->data_len += count;
    ret = count;
    
    mutex_unlock(&dev->mutex);
    
    /* 唤醒读等待队列 */
    wake_up_interruptible(&dev->read_queue);
    
    /* 发送异步通知信号 */
    if (dev->async_queue)
        kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
    
    printk(KERN_INFO "io_model_dev: Written %zd bytes\n", ret);
    return ret;
}

/* ==================== poll 函数（IO多路复用支持） ==================== */
static unsigned int iodev_poll(struct file *filp, poll_table *wait)
{
    struct io_model_device *dev = filp->private_data;
    unsigned int mask = 0;
    
    mutex_lock(&dev->mutex);
    
    /* 将等待队列添加到poll表 */
    poll_wait(filp, &dev->read_queue, wait);
    poll_wait(filp, &dev->write_queue, wait);
    
    /* 检查可读条件 */
    if (dev->data_len > 0)
        mask |= POLLIN | POLLRDNORM;  /* 可读 */
    
    /* 检查可写条件 */
    if (dev->data_len < BUFFER_SIZE)
        mask |= POLLOUT | POLLWRNORM; /* 可写 */
    
    mutex_unlock(&dev->mutex);
    
    printk(KERN_DEBUG "io_model_dev: Poll returned mask=0x%x\n", mask);
    return mask;
}

/* ==================== fasync 函数（异步通知支持） ==================== */
static int iodev_fasync(int fd, struct file *filp, int on)
{
    struct io_model_device *dev = filp->private_data;
    
    printk(KERN_INFO "io_model_dev: fasync called, fd=%d, on=%d\n", fd, on);
    return fasync_helper(fd, filp, on, &dev->async_queue);
}

/* ==================== 文件操作结构体 ==================== */
static struct file_operations iodev_fops = {
    .owner = THIS_MODULE,
    .open = iodev_open,
    .release = iodev_release,
    .read = iodev_read,
    .write = iodev_write,
    .poll = iodev_poll,
    .fasync = iodev_fasync,
};

/* ==================== 模块初始化 ==================== */
static int __init iodev_init(void)
{
    int ret;
    
    printk(KERN_INFO "io_model_dev: Initializing module\n");
    
    /* 分配设备结构体 */
    iodev = kzalloc(sizeof(struct io_model_device), GFP_KERNEL);
    if (!iodev)
        return -ENOMEM;
    
    /* 分配缓冲区 */
    iodev->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
    if (!iodev->buffer) {
        kfree(iodev);
        return -ENOMEM;
    }
    iodev->data_len = 0;
    
    /* 初始化等待队列 */
    init_waitqueue_head(&iodev->read_queue);
    init_waitqueue_head(&iodev->write_queue);
    
    /* 初始化互斥锁 */
    mutex_init(&iodev->mutex);
    
    /* 分配设备号 */
    ret = alloc_chrdev_region(&iodev->devno, 0, DEVICE_COUNT, DEVICE_NAME);
    if (ret < 0) {
        printk(KERN_ERR "io_model_dev: Failed to allocate device number\n");
        goto fail_alloc;
    }
    
    /* 初始化并注册字符设备 */
    cdev_init(&iodev->cdev, &iodev_fops);
    iodev->cdev.owner = THIS_MODULE;
    ret = cdev_add(&iodev->cdev, iodev->devno, DEVICE_COUNT);
    if (ret < 0) {
        printk(KERN_ERR "io_model_dev: Failed to add cdev\n");
        goto fail_cdev;
    }
    
    /* 创建设备类 */
    iodev->class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(iodev->class)) {
        ret = PTR_ERR(iodev->class);
        goto fail_class;
    }
    
    /* 创建设备节点 */
    iodev->device = device_create(iodev->class, NULL, iodev->devno, 
                                   NULL, DEVICE_NAME);
    if (IS_ERR(iodev->device)) {
        ret = PTR_ERR(iodev->device);
        goto fail_device;
    }
    
    printk(KERN_INFO "io_model_dev: Device created at /dev/%s\n", DEVICE_NAME);
    return 0;

fail_device:
    class_destroy(iodev->class);
fail_class:
    cdev_del(&iodev->cdev);
fail_cdev:
    unregister_chrdev_region(iodev->devno, DEVICE_COUNT);
fail_alloc:
    kfree(iodev->buffer);
    kfree(iodev);
    return ret;
}

/* ==================== 模块退出 ==================== */
static void __exit iodev_exit(void)
{
    printk(KERN_INFO "io_model_dev: Exiting module\n");
    
    device_destroy(iodev->class, iodev->devno);
    class_destroy(iodev->class);
    cdev_del(&iodev->cdev);
    unregister_chrdev_region(iodev->devno, DEVICE_COUNT);
    kfree(iodev->buffer);
    kfree(iodev);
    
    printk(KERN_INFO "io_model_dev: Module exited\n");
}

module_init(iodev_init);
module_exit(iodev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Linux IO Model Example Driver");
MODULE_VERSION("1.0");
```

### 3.2 Makefile

```makefile
obj-m := io_model_dev.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```

### 3.3 用户空间测试程序

#### 阻塞IO测试（test_blocking.c）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#define DEVICE_PATH "/dev/io_model_dev"

int main()
{
    int fd;
    char buf[128];
    ssize_t ret;
    
    printf("=== 阻塞IO测试 ===\n");
    
    /* 以阻塞模式打开设备 */
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    
    printf("设备已打开（阻塞模式）\n");
    printf("正在尝试读取数据（将阻塞直到有数据写入）...\n");
    
    /* 阻塞读取 - 需要另一个进程写入数据才能返回 */
    ret = read(fd, buf, sizeof(buf) - 1);
    if (ret < 0) {
        perror("read");
        close(fd);
        return EXIT_FAILURE;
    }
    
    buf[ret] = '\0';
    printf("读取到 %zd 字节: %s\n", ret, buf);
    
    close(fd);
    return EXIT_SUCCESS;
}
```

#### 非阻塞IO测试（test_nonblocking.c）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#define DEVICE_PATH "/dev/io_model_dev"

int main()
{
    int fd;
    char buf[128];
    ssize_t ret;
    int retry = 0;
    
    printf("=== 非阻塞IO测试 ===\n");
    
    /* 以非阻塞模式打开设备 */
    fd = open(DEVICE_PATH, O_RDWR | O_NONBLOCK);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    
    printf("设备已打开（非阻塞模式）\n");
    
    /* 先写入一些数据 */
    const char *msg = "Hello, Non-blocking IO!";
    ret = write(fd, msg, strlen(msg));
    if (ret < 0) {
        if (errno == EAGAIN) {
            printf("写入：缓冲区满，稍后重试\n");
        } else {
            perror("write");
        }
    } else {
        printf("写入 %zd 字节\n", ret);
    }
    
    /* 非阻塞读取 */
    while (retry < 3) {
        ret = read(fd, buf, sizeof(buf) - 1);
        if (ret < 0) {
            if (errno == EAGAIN) {
                printf("读取：数据未就绪，重试 %d/3\n", ++retry);
                usleep(100000);  /* 等待100ms */
                continue;
            }
            perror("read");
            break;
        }
        
        buf[ret] = '\0';
        printf("读取到 %zd 字节: %s\n", ret, buf);
        break;
    }
    
    close(fd);
    return EXIT_SUCCESS;
}
```

#### IO多路复用测试（test_poll.c）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>
#include <errno.h>

#define DEVICE_PATH "/dev/io_model_dev"

int main()
{
    int fd;
    struct pollfd fds[1];
    char buf[128];
    int ret;
    
    printf("=== IO多路复用（poll）测试 ===\n");
    
    fd = open(DEVICE_PATH, O_RDWR | O_NONBLOCK);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    
    /* 设置poll结构 */
    fds[0].fd = fd;
    fds[0].events = POLLIN | POLLOUT;
    
    printf("开始监控设备（超时5秒）...\n");
    
    while (1) {
        ret = poll(fds, 1, 5000);  /* 5秒超时 */
        
        if (ret < 0) {
            perror("poll");
            break;
        } else if (ret == 0) {
            printf("poll超时\n");
            break;
        }
        
        /* 检查可读事件 */
        if (fds[0].revents & POLLIN) {
            printf("设备可读\n");
            ssize_t n = read(fd, buf, sizeof(buf) - 1);
            if (n > 0) {
                buf[n] = '\0';
                printf("读取: %s\n", buf);
            }
        }
        
        /* 检查可写事件 */
        if (fds[0].revents & POLLOUT) {
            printf("设备可写\n");
            const char *msg = "Poll test message";
            write(fd, msg, strlen(msg));
        }
        
        /* 检查错误 */
        if (fds[0].revents & (POLLERR | POLLHUP)) {
            printf("设备错误或挂起\n");
            break;
        }
        
        sleep(1);
    }
    
    close(fd);
    return EXIT_SUCCESS;
}
```

#### 异步通知测试（test_async.c）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

#define DEVICE_PATH "/dev/io_model_dev"

static int fd;
static volatile int got_signal = 0;

/* SIGIO信号处理函数 */
void sigio_handler(int signo)
{
    char buf[128];
    ssize_t ret;
    
    printf("\n收到SIGIO信号！\n");
    got_signal = 1;
    
    /* 读取数据 */
    ret = read(fd, buf, sizeof(buf) - 1);
    if (ret > 0) {
        buf[ret] = '\0';
        printf("异步读取: %s\n", buf);
    }
}

int main()
{
    int oflags;
    
    printf("=== 异步通知（信号驱动IO）测试 ===\n");
    
    /* 打开设备 */
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    
    /* 设置信号处理函数 */
    signal(SIGIO, sigio_handler);
    
    /* 设置文件描述符的所有者为本进程 */
    fcntl(fd, F_SETOWN, getpid());
    
    /* 获取当前文件标志并添加FASYNC标志 */
    oflags = fcntl(fd, F_GETFL);
    fcntl(fd, F_SETFL, oflags | FASYNC);
    
    printf("异步通知已设置，PID=%d\n", getpid());
    printf("请从另一个终端向设备写入数据：\n");
    printf("  echo 'test' | sudo tee /dev/io_model_dev\n");
    printf("等待信号（10秒超时）...\n");
    
    /* 等待信号 */
    int timeout = 10;
    while (!got_signal && timeout > 0) {
        sleep(1);
        timeout--;
        printf(".");
        fflush(stdout);
    }
    
    if (!got_signal) {
        printf("\n超时，未收到信号\n");
    }
    
    close(fd);
    return EXIT_SUCCESS;
}
```

#### select测试（test_select.c）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>
#include <errno.h>

#define DEVICE_PATH "/dev/io_model_dev"

int main()
{
    int fd;
    fd_set read_fds, write_fds;
    struct timeval timeout;
    char buf[128];
    int ret;
    
    printf("=== IO多路复用（select）测试 ===\n");
    
    fd = open(DEVICE_PATH, O_RDWR | O_NONBLOCK);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    
    /* 先写入测试数据 */
    const char *msg = "Select test data";
    write(fd, msg, strlen(msg));
    printf("已写入测试数据\n");
    
    /* 使用select监控 */
    FD_ZERO(&read_fds);
    FD_ZERO(&write_fds);
    FD_SET(fd, &read_fds);
    FD_SET(fd, &write_fds);
    
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    
    printf("调用select等待（5秒超时）...\n");
    
    ret = select(fd + 1, &read_fds, &write_fds, NULL, &timeout);
    
    if (ret < 0) {
        perror("select");
    } else if (ret == 0) {
        printf("select超时\n");
    } else {
        printf("select返回，ret=%d\n", ret);
        
        if (FD_ISSET(fd, &read_fds)) {
            printf("  - 设备可读\n");
            ssize_t n = read(fd, buf, sizeof(buf) - 1);
            if (n > 0) {
                buf[n] = '\0';
                printf("  - 读取数据: %s\n", buf);
            }
        }
        
        if (FD_ISSET(fd, &write_fds)) {
            printf("  - 设备可写\n");
        }
    }
    
    close(fd);
    return EXIT_SUCCESS;
}
```

### 3.4 测试脚本（test.sh）

```bash
#!/bin/bash

echo "=== Linux IO模型驱动测试 ==="
echo ""

# 编译驱动
echo "[1] 编译内核模块..."
make clean && make
if [ $? -ne 0 ]; then
    echo "错误：模块编译失败"
    exit 1
fi
echo "✓ 模块编译成功"
echo ""

# 加载模块
echo "[2] 加载内核模块..."
sudo insmod io_model_dev.ko
if [ $? -ne 0 ]; then
    echo "错误：模块加载失败"
    exit 1
fi
echo "✓ 模块加载成功"
echo ""

# 设置权限
echo "[3] 设置设备权限..."
sudo chmod 666 /dev/io_model_dev
ls -l /dev/io_model_dev
echo ""

# 编译测试程序
echo "[4] 编译测试程序..."
gcc -o test_nonblocking test_nonblocking.c
gcc -o test_poll test_poll.c
gcc -o test_select test_select.c
gcc -o test_async test_async.c
echo "✓ 测试程序编译完成"
echo ""

# 运行非阻塞测试
echo "[5] 运行非阻塞IO测试..."
./test_nonblocking
echo ""

# 运行select测试
echo "[6] 运行select测试..."
./test_select
echo ""

# 查看内核日志
echo "[7] 内核日志："
dmesg | tail -20 | grep io_model_dev
echo ""

# 清理
echo "[8] 清理..."
read -p "按Enter键卸载模块并清理..."
sudo rmmod io_model_dev
make clean
rm -f test_nonblocking test_poll test_select test_async test_blocking
echo "✓ 清理完成"
```

### 3.5 使用说明

#### 编译与加载
```bash
# 编译驱动
make

# 加载驱动
sudo insmod io_model_dev.ko

# 设置权限
sudo chmod 666 /dev/io_model_dev
```

#### 基本测试
```bash
# 写入数据
echo "Hello" > /dev/io_model_dev

# 读取数据
cat /dev/io_model_dev
```

#### 阻塞测试（需要两个终端）
```bash
# 终端1：阻塞读取（会等待数据）
./test_blocking

# 终端2：写入数据（触发终端1返回）
echo "Wake up!" > /dev/io_model_dev
```

#### 查看日志
```bash
dmesg | grep io_model_dev
```

#### 卸载驱动
```bash
sudo rmmod io_model_dev
```

---

## 附录：IO模型对比表

| 特性 | 阻塞IO | 非阻塞IO | IO多路复用 | 信号驱动IO |
|------|--------|----------|------------|------------|
| 等待数据 | 睡眠等待 | 立即返回 | 统一等待 | 信号通知 |
| CPU利用 | 低 | 高（轮询） | 中 | 低 |
| 编程复杂度 | 低 | 中 | 中 | 高 |
| 适用场景 | 单设备 | 多任务 | 多设备 | 异步需求 |
| 驱动实现 | 等待队列 | 状态检查 | poll函数 | fasync机制 |

## 附录：file_operations 中IO相关成员

```c
struct file_operations {
    // ...
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    unsigned int (*poll) (struct file *, struct poll_table_struct *);
    int (*fasync) (int, struct file *, int);
    // ...
};
```
